// Generated Code - DO NOT EDIT !!
// generated by 'emugen'
#include <stdio.h>
#include <stdlib.h>
#include "gles_client_context.h"
#include "ErrorLog.h"

#ifndef GLsync
typedef struct __GLsync *GLsync;
#endif


#ifndef GL_TRUE
extern "C" {
	void RedFinger_glActiveTexture(GLenum texture);
	void RedFinger_glAttachShader(GLuint program, GLuint shader);
	void RedFinger_glBindAttribLocation(GLuint program, GLuint index, const GLchar* name);
	void RedFinger_glBindBuffer(GLenum target, GLuint buffer);
	void RedFinger_glBindFramebuffer(GLenum target, GLuint framebuffer);
	void RedFinger_glBindRenderbuffer(GLenum target, GLuint renderbuffer);
	void RedFinger_glBindTexture(GLenum target, GLuint texture);
	void RedFinger_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
	void RedFinger_glBlendEquation(GLenum mode);
	void RedFinger_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
	void RedFinger_glBlendFunc(GLenum sfactor, GLenum dfactor);
	void RedFinger_glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
	void RedFinger_glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);
	void RedFinger_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);
	GLenum RedFinger_glCheckFramebufferStatus(GLenum target);
	void RedFinger_glClear(GLbitfield mask);
	void RedFinger_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
	void RedFinger_glClearDepthf(GLclampf depth);
	void RedFinger_glClearStencil(GLint s);
	void RedFinger_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
	void RedFinger_glCompileShader(GLuint shader);
	void RedFinger_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data);
	void RedFinger_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data);
	void RedFinger_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
	void RedFinger_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	GLuint RedFinger_glCreateProgram();
	GLuint RedFinger_glCreateShader(GLenum type);
	void RedFinger_glCullFace(GLenum mode);
	void RedFinger_glDeleteBuffers(GLsizei n, const GLuint* buffers);
	void RedFinger_glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers);
	void RedFinger_glDeleteProgram(GLuint program);
	void RedFinger_glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers);
	void RedFinger_glDeleteShader(GLuint shader);
	void RedFinger_glDeleteTextures(GLsizei n, const GLuint* textures);
	void RedFinger_glDepthFunc(GLenum func);
	void RedFinger_glDepthMask(GLboolean flag);
	void RedFinger_glDepthRangef(GLclampf zNear, GLclampf zFar);
	void RedFinger_glDetachShader(GLuint program, GLuint shader);
	void RedFinger_glDisable(GLenum cap);
	void RedFinger_glDisableVertexAttribArray(GLuint index);
	void RedFinger_glDrawArrays(GLenum mode, GLint first, GLsizei count);
	void RedFinger_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices);
	void RedFinger_glEnable(GLenum cap);
	void RedFinger_glEnableVertexAttribArray(GLuint index);
	void RedFinger_glFinish();
	void RedFinger_glFlush();
	void RedFinger_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	void RedFinger_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	void RedFinger_glFrontFace(GLenum mode);
	void RedFinger_glGenBuffers(GLsizei n, GLuint* buffers);
	void RedFinger_glGenerateMipmap(GLenum target);
	void RedFinger_glGenFramebuffers(GLsizei n, GLuint* framebuffers);
	void RedFinger_glGenRenderbuffers(GLsizei n, GLuint* renderbuffers);
	void RedFinger_glGenTextures(GLsizei n, GLuint* textures);
	void RedFinger_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
	void RedFinger_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
	void RedFinger_glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders);
	int RedFinger_glGetAttribLocation(GLuint program, const GLchar* name);
	void RedFinger_glGetBooleanv(GLenum pname, GLboolean* params);
	void RedFinger_glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params);
	GLenum RedFinger_glGetError();
	void RedFinger_glGetFloatv(GLenum pname, GLfloat* params);
	void RedFinger_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params);
	void RedFinger_glGetIntegerv(GLenum pname, GLint* params);
	void RedFinger_glGetProgramiv(GLuint program, GLenum pname, GLint* params);
	void RedFinger_glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog);
	void RedFinger_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params);
	void RedFinger_glGetShaderiv(GLuint shader, GLenum pname, GLint* params);
	void RedFinger_glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog);
	void RedFinger_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision);
	void RedFinger_glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);
	const GLubyte* RedFinger_glGetString(GLenum name);
	void RedFinger_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params);
	void RedFinger_glGetTexParameteriv(GLenum target, GLenum pname, GLint* params);
	void RedFinger_glGetUniformfv(GLuint program, GLint location, GLfloat* params);
	void RedFinger_glGetUniformiv(GLuint program, GLint location, GLint* params);
	int RedFinger_glGetUniformLocation(GLuint program, const GLchar* name);
	void RedFinger_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params);
	void RedFinger_glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params);
	void RedFinger_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer);
	void RedFinger_glHint(GLenum target, GLenum mode);
	GLboolean RedFinger_glIsBuffer(GLuint buffer);
	GLboolean RedFinger_glIsEnabled(GLenum cap);
	GLboolean RedFinger_glIsFramebuffer(GLuint framebuffer);
	GLboolean RedFinger_glIsProgram(GLuint program);
	GLboolean RedFinger_glIsRenderbuffer(GLuint renderbuffer);
	GLboolean RedFinger_glIsShader(GLuint shader);
	GLboolean RedFinger_glIsTexture(GLuint texture);
	void RedFinger_glLineWidth(GLfloat width);
	void RedFinger_glLinkProgram(GLuint program);
	void RedFinger_glPixelStorei(GLenum pname, GLint param);
	void RedFinger_glPolygonOffset(GLfloat factor, GLfloat units);
	void RedFinger_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);
	void RedFinger_glReleaseShaderCompiler();
	void RedFinger_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
	void RedFinger_glSampleCoverage(GLclampf value, GLboolean invert);
	void RedFinger_glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
	void RedFinger_glShaderBinary(GLsizei n, const GLuint* shaders, GLenum binaryformat, const GLvoid* binary, GLsizei length);
	void RedFinger_glShaderSource(GLuint shader, GLsizei count, const GLchar*const* string, const GLint* length);
	void RedFinger_glStencilFunc(GLenum func, GLint ref, GLuint mask);
	void RedFinger_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
	void RedFinger_glStencilMask(GLuint mask);
	void RedFinger_glStencilMaskSeparate(GLenum face, GLuint mask);
	void RedFinger_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
	void RedFinger_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);
	void RedFinger_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels);
	void RedFinger_glTexParameterf(GLenum target, GLenum pname, GLfloat param);
	void RedFinger_glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params);
	void RedFinger_glTexParameteri(GLenum target, GLenum pname, GLint param);
	void RedFinger_glTexParameteriv(GLenum target, GLenum pname, const GLint* params);
	void RedFinger_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels);
	void RedFinger_glUniform1f(GLint location, GLfloat x);
	void RedFinger_glUniform1fv(GLint location, GLsizei count, const GLfloat* v);
	void RedFinger_glUniform1i(GLint location, GLint x);
	void RedFinger_glUniform1iv(GLint location, GLsizei count, const GLint* v);
	void RedFinger_glUniform2f(GLint location, GLfloat x, GLfloat y);
	void RedFinger_glUniform2fv(GLint location, GLsizei count, const GLfloat* v);
	void RedFinger_glUniform2i(GLint location, GLint x, GLint y);
	void RedFinger_glUniform2iv(GLint location, GLsizei count, const GLint* v);
	void RedFinger_glUniform3f(GLint location, GLfloat x, GLfloat y, GLfloat z);
	void RedFinger_glUniform3fv(GLint location, GLsizei count, const GLfloat* v);
	void RedFinger_glUniform3i(GLint location, GLint x, GLint y, GLint z);
	void RedFinger_glUniform3iv(GLint location, GLsizei count, const GLint* v);
	void RedFinger_glUniform4f(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void RedFinger_glUniform4fv(GLint location, GLsizei count, const GLfloat* v);
	void RedFinger_glUniform4i(GLint location, GLint x, GLint y, GLint z, GLint w);
	void RedFinger_glUniform4iv(GLint location, GLsizei count, const GLint* v);
	void RedFinger_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glUseProgram(GLuint program);
	void RedFinger_glValidateProgram(GLuint program);
	void RedFinger_glVertexAttrib1f(GLuint indx, GLfloat x);
	void RedFinger_glVertexAttrib1fv(GLuint indx, const GLfloat* values);
	void RedFinger_glVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);
	void RedFinger_glVertexAttrib2fv(GLuint indx, const GLfloat* values);
	void RedFinger_glVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);
	void RedFinger_glVertexAttrib3fv(GLuint indx, const GLfloat* values);
	void RedFinger_glVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
	void RedFinger_glVertexAttrib4fv(GLuint indx, const GLfloat* values);
	void RedFinger_glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr);
	void RedFinger_glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
	void RedFinger_glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image);
	void RedFinger_glEGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image);
	void RedFinger_glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, GLvoid* binary);
	void RedFinger_glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid* binary, GLint length);
	void* RedFinger_glMapBufferOES(GLenum target, GLenum access);
	GLboolean RedFinger_glUnmapBufferOES(GLenum target);
	void RedFinger_glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* pixels);
	void RedFinger_glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels);
	void RedFinger_glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	void RedFinger_glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data);
	void RedFinger_glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data);
	void RedFinger_glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
	void RedFinger_glBindVertexArrayOES(GLuint array);
	void RedFinger_glDeleteVertexArraysOES(GLsizei n, const GLuint* arrays);
	void RedFinger_glGenVertexArraysOES(GLsizei n, GLuint* arrays);
	GLboolean RedFinger_glIsVertexArrayOES(GLuint array);
	void RedFinger_glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum* attachments);
	void RedFinger_glMultiDrawArraysEXT(GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount);
	void RedFinger_glMultiDrawElementsEXT(GLenum mode, const GLsizei* count, GLenum type, const GLvoid*const* indices, GLsizei primcount);
	void RedFinger_glGetPerfMonitorGroupsAMD(GLint* numGroups, GLsizei groupsSize, GLuint* groups);
	void RedFinger_glGetPerfMonitorCountersAMD(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters);
	void RedFinger_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString);
	void RedFinger_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString);
	void RedFinger_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid* data);
	void RedFinger_glGenPerfMonitorsAMD(GLsizei n, GLuint* monitors);
	void RedFinger_glDeletePerfMonitorsAMD(GLsizei n, GLuint* monitors);
	void RedFinger_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* countersList);
	void RedFinger_glBeginPerfMonitorAMD(GLuint monitor);
	void RedFinger_glEndPerfMonitorAMD(GLuint monitor);
	void RedFinger_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten);
	void RedFinger_glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	void RedFinger_glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
	void RedFinger_glDeleteFencesNV(GLsizei n, const GLuint* fences);
	void RedFinger_glGenFencesNV(GLsizei n, GLuint* fences);
	GLboolean RedFinger_glIsFenceNV(GLuint fence);
	GLboolean RedFinger_glTestFenceNV(GLuint fence);
	void RedFinger_glGetFenceivNV(GLuint fence, GLenum pname, GLint* params);
	void RedFinger_glFinishFenceNV(GLuint fence);
	void RedFinger_glSetFenceNV(GLuint fence, GLenum condition);
	void RedFinger_glCoverageMaskNV(GLboolean mask);
	void RedFinger_glCoverageOperationNV(GLenum operation);
	void RedFinger_glGetDriverControlsQCOM(GLint* num, GLsizei size, GLuint* driverControls);
	void RedFinger_glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar* driverControlString);
	void RedFinger_glEnableDriverControlQCOM(GLuint driverControl);
	void RedFinger_glDisableDriverControlQCOM(GLuint driverControl);
	void RedFinger_glExtGetTexturesQCOM(GLuint* textures, GLint maxTextures, GLint* numTextures);
	void RedFinger_glExtGetBuffersQCOM(GLuint* buffers, GLint maxBuffers, GLint* numBuffers);
	void RedFinger_glExtGetRenderbuffersQCOM(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers);
	void RedFinger_glExtGetFramebuffersQCOM(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers);
	void RedFinger_glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params);
	void RedFinger_glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param);
	void RedFinger_glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid* texels);
	void RedFinger_glExtGetBufferPointervQCOM(GLenum target, GLvoidptr* params);
	void RedFinger_glExtGetShadersQCOM(GLuint* shaders, GLint maxShaders, GLint* numShaders);
	void RedFinger_glExtGetProgramsQCOM(GLuint* programs, GLint maxPrograms, GLint* numPrograms);
	GLboolean RedFinger_glExtIsProgramBinaryQCOM(GLuint program);
	void RedFinger_glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar* source, GLint* length);
	void RedFinger_glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
	void RedFinger_glEndTilingQCOM(GLbitfield preserveMask);
	void RedFinger_glVertexAttribPointerData(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, void* data, GLuint datalen);
	void RedFinger_glVertexAttribPointerOffset(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint offset);
	void RedFinger_glDrawElementsOffset(GLenum mode, GLsizei count, GLenum type, GLuint offset);
	void RedFinger_glDrawElementsData(GLenum mode, GLsizei count, GLenum type, void* data, GLuint datalen);
	void RedFinger_glGetCompressedTextureFormats(int count, GLint* formats);
	void RedFinger_glShaderString(GLuint shader, const GLchar* string, GLsizei len);
	int RedFinger_glFinishRoundTrip();
	void RedFinger_glGenVertexArrays(GLsizei n, GLuint* arrays);
	void RedFinger_glBindVertexArray(GLuint array);
	void RedFinger_glDeleteVertexArrays(GLsizei n, const GLuint* arrays);
	GLboolean RedFinger_glIsVertexArray(GLuint array);
	void* RedFinger_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
	GLboolean RedFinger_glUnmapBuffer(GLenum target);
	void RedFinger_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);
	void RedFinger_glMapBufferRangeAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* mapped);
	void RedFinger_glUnmapBufferAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer, GLboolean* out_res);
	void RedFinger_glFlushMappedBufferRangeAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer);
	void RedFinger_glReadPixelsOffsetAEMU(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset);
	void RedFinger_glCompressedTexImage2DOffsetAEMU(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLuint offset);
	void RedFinger_glCompressedTexSubImage2DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLuint offset);
	void RedFinger_glTexImage2DOffsetAEMU(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLuint offset);
	void RedFinger_glTexSubImage2DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset);
	void RedFinger_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
	void RedFinger_glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
	void RedFinger_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
	void RedFinger_glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint* value);
	void RedFinger_glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint* value);
	void RedFinger_glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat* value);
	void RedFinger_glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
	void RedFinger_glGetBufferParameteri64v(GLenum target, GLenum value, GLint64* data);
	void RedFinger_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid** params);
	void RedFinger_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
	GLuint RedFinger_glGetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName);
	void RedFinger_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar** var3, GLuint* uniformIndices);
	void RedFinger_glGetUniformIndicesAEMU(GLuint program, GLsizei uniformCount, const GLchar* packedUniformNames, GLsizei packedLen, GLuint* uniformIndices);
	void RedFinger_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
	void RedFinger_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
	void RedFinger_glUniform1ui(GLint location, GLuint v0);
	void RedFinger_glUniform2ui(GLint location, GLuint v0, GLuint v1);
	void RedFinger_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);
	void RedFinger_glUniform4ui(GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3);
	void RedFinger_glUniform1uiv(GLint location, GLsizei count, const GLuint* value);
	void RedFinger_glUniform2uiv(GLint location, GLsizei count, const GLuint* value);
	void RedFinger_glUniform3uiv(GLint location, GLsizei count, const GLuint* value);
	void RedFinger_glUniform4uiv(GLint location, GLsizei count, const GLuint* value);
	void RedFinger_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glGetUniformuiv(GLuint program, GLint location, GLuint* params);
	void RedFinger_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
	void RedFinger_glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
	void RedFinger_glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
	void RedFinger_glVertexAttribI4iv(GLuint index, const GLint* v);
	void RedFinger_glVertexAttribI4uiv(GLuint index, const GLuint* v);
	void RedFinger_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
	void RedFinger_glVertexAttribIPointerOffsetAEMU(GLuint index, GLint size, GLenum type, GLsizei stride, GLuint offset);
	void RedFinger_glVertexAttribIPointerDataAEMU(GLuint index, GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen);
	void RedFinger_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint* params);
	void RedFinger_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params);
	void RedFinger_glVertexAttribDivisor(GLuint index, GLuint divisor);
	void RedFinger_glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
	void RedFinger_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
	void RedFinger_glDrawElementsInstancedDataAEMU(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount, GLsizei datalen);
	void RedFinger_glDrawElementsInstancedOffsetAEMU(GLenum mode, GLsizei count, GLenum type, GLuint offset, GLsizei primcount);
	void RedFinger_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices);
	void RedFinger_glDrawRangeElementsDataAEMU(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices, GLsizei datalen);
	void RedFinger_glDrawRangeElementsOffsetAEMU(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLuint offset);
	GLsync RedFinger_glFenceSync(GLenum condition, GLbitfield flags);
	GLenum RedFinger_glClientWaitSync(GLsync wait_on, GLbitfield flags, GLuint64 timeout);
	void RedFinger_glWaitSync(GLsync wait_on, GLbitfield flags, GLuint64 timeout);
	void RedFinger_glDeleteSync(GLsync to_delete);
	GLboolean RedFinger_glIsSync(GLsync sync);
	void RedFinger_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values);
	uint64_t RedFinger_glFenceSyncAEMU(GLenum condition, GLbitfield flags);
	GLenum RedFinger_glClientWaitSyncAEMU(uint64_t wait_on, GLbitfield flags, GLuint64 timeout);
	void RedFinger_glWaitSyncAEMU(uint64_t wait_on, GLbitfield flags, GLuint64 timeout);
	void RedFinger_glDeleteSyncAEMU(uint64_t to_delete);
	GLboolean RedFinger_glIsSyncAEMU(uint64_t sync);
	void RedFinger_glGetSyncivAEMU(uint64_t sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values);
	void RedFinger_glDrawBuffers(GLsizei n, const GLenum* bufs);
	void RedFinger_glReadBuffer(GLenum src);
	void RedFinger_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
	void RedFinger_glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments);
	void RedFinger_glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
	void RedFinger_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
	void RedFinger_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
	void RedFinger_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
	void RedFinger_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);
	void RedFinger_glBeginTransformFeedback(GLenum primitiveMode);
	void RedFinger_glEndTransformFeedback();
	void RedFinger_glGenTransformFeedbacks(GLsizei n, GLuint* ids);
	void RedFinger_glDeleteTransformFeedbacks(GLsizei n, const GLuint* ids);
	void RedFinger_glBindTransformFeedback(GLenum target, GLuint id);
	void RedFinger_glPauseTransformFeedback();
	void RedFinger_glResumeTransformFeedback();
	GLboolean RedFinger_glIsTransformFeedback(GLuint id);
	void RedFinger_glTransformFeedbackVaryings(GLuint program, GLsizei count, const char** var3, GLenum bufferMode);
	void RedFinger_glTransformFeedbackVaryingsAEMU(GLuint program, GLsizei count, const char* packedVaryings, GLuint packedVaryingsLen, GLenum bufferMode);
	void RedFinger_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, char* name);
	void RedFinger_glGenSamplers(GLsizei n, GLuint* samplers);
	void RedFinger_glDeleteSamplers(GLsizei n, const GLuint* samplers);
	void RedFinger_glBindSampler(GLuint unit, GLuint sampler);
	void RedFinger_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);
	void RedFinger_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
	void RedFinger_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* params);
	void RedFinger_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint* params);
	void RedFinger_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params);
	void RedFinger_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params);
	GLboolean RedFinger_glIsSampler(GLuint sampler);
	void RedFinger_glGenQueries(GLsizei n, GLuint* queries);
	void RedFinger_glDeleteQueries(GLsizei n, const GLuint* queries);
	void RedFinger_glBeginQuery(GLenum target, GLuint query);
	void RedFinger_glEndQuery(GLenum target);
	void RedFinger_glGetQueryiv(GLenum target, GLenum pname, GLint* params);
	void RedFinger_glGetQueryObjectuiv(GLuint query, GLenum pname, GLuint* params);
	GLboolean RedFinger_glIsQuery(GLuint query);
	void RedFinger_glProgramParameteri(GLuint program, GLenum pname, GLint value);
	void RedFinger_glProgramBinary(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length);
	void RedFinger_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary);
	GLint RedFinger_glGetFragDataLocation(GLuint program, const char* name);
	void RedFinger_glGetInteger64v(GLenum pname, GLint64* data);
	void RedFinger_glGetIntegeri_v(GLenum target, GLuint index, GLint* data);
	void RedFinger_glGetInteger64i_v(GLenum target, GLuint index, GLint64* data);
	void RedFinger_glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* data);
	void RedFinger_glTexImage3DOffsetAEMU(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLuint offset);
	void RedFinger_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
	void RedFinger_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data);
	void RedFinger_glTexSubImage3DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLuint offset);
	void RedFinger_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data);
	void RedFinger_glCompressedTexImage3DOffsetAEMU(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLuint offset);
	void RedFinger_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data);
	void RedFinger_glCompressedTexSubImage3DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLuint data);
	void RedFinger_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
	const GLubyte* RedFinger_glGetStringi(GLenum name, GLuint index);
	void RedFinger_glGetBooleani_v(GLenum target, GLuint index, GLboolean* data);
	void RedFinger_glMemoryBarrier(GLbitfield barriers);
	void RedFinger_glMemoryBarrierByRegion(GLbitfield barriers);
	void RedFinger_glGenProgramPipelines(GLsizei n, GLuint* pipelines);
	void RedFinger_glDeleteProgramPipelines(GLsizei n, const GLuint* pipelines);
	void RedFinger_glBindProgramPipeline(GLuint pipeline);
	void RedFinger_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint* params);
	void RedFinger_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
	void RedFinger_glValidateProgramPipeline(GLuint pipeline);
	GLboolean RedFinger_glIsProgramPipeline(GLuint pipeline);
	void RedFinger_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
	void RedFinger_glActiveShaderProgram(GLuint pipeline, GLuint program);
	GLuint RedFinger_glCreateShaderProgramv(GLenum type, GLsizei count, const char** var3);
	GLuint RedFinger_glCreateShaderProgramvAEMU(GLenum type, GLsizei count, const char* packedStrings, GLuint packedLen);
	void RedFinger_glProgramUniform1f(GLuint program, GLint location, GLfloat v0);
	void RedFinger_glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);
	void RedFinger_glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
	void RedFinger_glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
	void RedFinger_glProgramUniform1i(GLuint program, GLint location, GLint v0);
	void RedFinger_glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);
	void RedFinger_glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
	void RedFinger_glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
	void RedFinger_glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
	void RedFinger_glProgramUniform2ui(GLuint program, GLint location, GLint v0, GLuint v1);
	void RedFinger_glProgramUniform3ui(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2);
	void RedFinger_glProgramUniform4ui(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3);
	void RedFinger_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	void RedFinger_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	void RedFinger_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	void RedFinger_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat* value);
	void RedFinger_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint* value);
	void RedFinger_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint* value);
	void RedFinger_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint* value);
	void RedFinger_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint* value);
	void RedFinger_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
	void RedFinger_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
	void RedFinger_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
	void RedFinger_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint* value);
	void RedFinger_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
	void RedFinger_glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint* params);
	void RedFinger_glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei* length, GLint* params);
	GLuint RedFinger_glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char* name);
	GLint RedFinger_glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char* name);
	void RedFinger_glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name);
	void RedFinger_glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
	void RedFinger_glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
	void RedFinger_glDispatchComputeIndirect(GLintptr indirect);
	void RedFinger_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride);
	void RedFinger_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
	void RedFinger_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
	void RedFinger_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
	void RedFinger_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);
	void RedFinger_glDrawArraysIndirect(GLenum mode, const void* indirect);
	void RedFinger_glDrawArraysIndirectDataAEMU(GLenum mode, const void* indirect, GLuint datalen);
	void RedFinger_glDrawArraysIndirectOffsetAEMU(GLenum mode, GLuint offset);
	void RedFinger_glDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect);
	void RedFinger_glDrawElementsIndirectDataAEMU(GLenum mode, GLenum type, const void* indirect, GLuint datalen);
	void RedFinger_glDrawElementsIndirectOffsetAEMU(GLenum mode, GLenum type, GLuint offset);
	void RedFinger_glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
	void RedFinger_glSampleMaski(GLuint maskNumber, GLbitfield mask);
	void RedFinger_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat* val);
	void RedFinger_glFramebufferParameteri(GLenum target, GLenum pname, GLint param);
	void RedFinger_glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint* params);
	void RedFinger_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params);
	void RedFinger_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params);
	void RedFinger_glAlphaFunc(GLenum func, GLclampf ref);
	void RedFinger_glClipPlanef(GLenum plane, const GLfloat* equation);
	void RedFinger_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
	void RedFinger_glFogf(GLenum pname, GLfloat param);
	void RedFinger_glFogfv(GLenum pname, const GLfloat* params);
	void RedFinger_glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
	void RedFinger_glGetClipPlanef(GLenum pname, GLfloat* eqn);
	void RedFinger_glGetLightfv(GLenum light, GLenum pname, GLfloat* params);
	void RedFinger_glGetMaterialfv(GLenum face, GLenum pname, GLfloat* params);
	void RedFinger_glGetTexEnvfv(GLenum env, GLenum pname, GLfloat* params);
	void RedFinger_glLightModelf(GLenum pname, GLfloat param);
	void RedFinger_glLightModelfv(GLenum pname, const GLfloat* params);
	void RedFinger_glLightf(GLenum light, GLenum pname, GLfloat param);
	void RedFinger_glLightfv(GLenum light, GLenum pname, const GLfloat* params);
	void RedFinger_glLoadMatrixf(const GLfloat* m);
	void RedFinger_glMaterialf(GLenum face, GLenum pname, GLfloat param);
	void RedFinger_glMaterialfv(GLenum face, GLenum pname, const GLfloat* params);
	void RedFinger_glMultMatrixf(const GLfloat* m);
	void RedFinger_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
	void RedFinger_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
	void RedFinger_glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
	void RedFinger_glPointParameterf(GLenum pname, GLfloat param);
	void RedFinger_glPointParameterfv(GLenum pname, const GLfloat* params);
	void RedFinger_glPointSize(GLfloat size);
	void RedFinger_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
	void RedFinger_glScalef(GLfloat x, GLfloat y, GLfloat z);
	void RedFinger_glTexEnvf(GLenum target, GLenum pname, GLfloat param);
	void RedFinger_glTexEnvfv(GLenum target, GLenum pname, const GLfloat* params);
	void RedFinger_glTranslatef(GLfloat x, GLfloat y, GLfloat z);
	void RedFinger_glAlphaFuncx(GLenum func, GLclampx ref);
	void RedFinger_glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
	void RedFinger_glClearDepthx(GLclampx depth);
	void RedFinger_glClientActiveTexture(GLenum texture);
	void RedFinger_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
	void RedFinger_glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
	void RedFinger_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
	void RedFinger_glDepthRangex(GLclampx zNear, GLclampx zFar);
	void RedFinger_glDisableClientState(GLenum array);
	void RedFinger_glEnableClientState(GLenum array);
	void RedFinger_glFogx(GLenum pname, GLfixed param);
	void RedFinger_glFogxv(GLenum pname, const GLfixed* params);
	void RedFinger_glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
	void RedFinger_glClipPlanex(GLenum pname, const GLfixed* eqn);
	void RedFinger_glGetFixedv(GLenum pname, GLfixed* params);
	void RedFinger_glGetLightxv(GLenum light, GLenum pname, GLfixed* params);
	void RedFinger_glGetMaterialxv(GLenum face, GLenum pname, GLfixed* params);
	void RedFinger_glGetPointerv(GLenum pname, GLvoid** params);
	void RedFinger_glGetTexEnviv(GLenum env, GLenum pname, GLint* params);
	void RedFinger_glGetTexEnvxv(GLenum env, GLenum pname, GLfixed* params);
	void RedFinger_glGetTexParameterxv(GLenum target, GLenum pname, GLfixed* params);
	void RedFinger_glLightModelx(GLenum pname, GLfixed param);
	void RedFinger_glLightModelxv(GLenum pname, const GLfixed* params);
	void RedFinger_glLightx(GLenum light, GLenum pname, GLfixed param);
	void RedFinger_glLightxv(GLenum light, GLenum pname, const GLfixed* params);
	void RedFinger_glLineWidthx(GLfixed width);
	void RedFinger_glLoadIdentity();
	void RedFinger_glLoadMatrixx(const GLfixed* m);
	void RedFinger_glLogicOp(GLenum opcode);
	void RedFinger_glMaterialx(GLenum face, GLenum pname, GLfixed param);
	void RedFinger_glMaterialxv(GLenum face, GLenum pname, const GLfixed* params);
	void RedFinger_glMatrixMode(GLenum mode);
	void RedFinger_glMultMatrixx(const GLfixed* m);
	void RedFinger_glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
	void RedFinger_glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz);
	void RedFinger_glNormalPointer(GLenum type, GLsizei stride, const GLvoid* pointer);
	void RedFinger_glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
	void RedFinger_glPointParameterx(GLenum pname, GLfixed param);
	void RedFinger_glPointParameterxv(GLenum pname, const GLfixed* params);
	void RedFinger_glPointSizex(GLfixed size);
	void RedFinger_glPolygonOffsetx(GLfixed factor, GLfixed units);
	void RedFinger_glPopMatrix();
	void RedFinger_glPushMatrix();
	void RedFinger_glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
	void RedFinger_glSampleCoveragex(GLclampx value, GLboolean invert);
	void RedFinger_glScalex(GLfixed x, GLfixed y, GLfixed z);
	void RedFinger_glShadeModel(GLenum mode);
	void RedFinger_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
	void RedFinger_glTexEnvi(GLenum target, GLenum pname, GLint param);
	void RedFinger_glTexEnvx(GLenum target, GLenum pname, GLfixed param);
	void RedFinger_glTexEnviv(GLenum target, GLenum pname, const GLint* params);
	void RedFinger_glTexEnvxv(GLenum target, GLenum pname, const GLfixed* params);
	void RedFinger_glTexParameterx(GLenum target, GLenum pname, GLfixed param);
	void RedFinger_glTexParameterxv(GLenum target, GLenum pname, const GLfixed* params);
	void RedFinger_glTranslatex(GLfixed x, GLfixed y, GLfixed z);
	void RedFinger_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
	void RedFinger_glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid* pointer);
	void RedFinger_glVertexPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset);
	void RedFinger_glColorPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset);
	void RedFinger_glNormalPointerOffset(GLenum type, GLsizei stride, GLuint offset);
	void RedFinger_glPointSizePointerOffset(GLenum type, GLsizei stride, GLuint offset);
	void RedFinger_glTexCoordPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset);
	void RedFinger_glWeightPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset);
	void RedFinger_glMatrixIndexPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset);
	void RedFinger_glVertexPointerData(GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen);
	void RedFinger_glColorPointerData(GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen);
	void RedFinger_glNormalPointerData(GLenum type, GLsizei stride, void* data, GLuint datalen);
	void RedFinger_glTexCoordPointerData(GLint unit, GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen);
	void RedFinger_glPointSizePointerData(GLenum type, GLsizei stride, void* data, GLuint datalen);
	void RedFinger_glWeightPointerData(GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen);
	void RedFinger_glMatrixIndexPointerData(GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen);
	void RedFinger_glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha);
	void RedFinger_glBlendFuncSeparateOES(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
	void RedFinger_glBlendEquationOES(GLenum mode);
	void RedFinger_glDrawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height);
	void RedFinger_glDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height);
	void RedFinger_glDrawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height);
	void RedFinger_glDrawTexsvOES(const GLshort* coords);
	void RedFinger_glDrawTexivOES(const GLint* coords);
	void RedFinger_glDrawTexxvOES(const GLfixed* coords);
	void RedFinger_glDrawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height);
	void RedFinger_glDrawTexfvOES(const GLfloat* coords);
	void RedFinger_glAlphaFuncxOES(GLenum func, GLclampx ref);
	void RedFinger_glClearColorxOES(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
	void RedFinger_glClearDepthxOES(GLclampx depth);
	void RedFinger_glClipPlanexOES(GLenum plane, const GLfixed* equation);
	void RedFinger_glClipPlanexIMG(GLenum plane, const GLfixed* equation);
	void RedFinger_glColor4xOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
	void RedFinger_glDepthRangexOES(GLclampx zNear, GLclampx zFar);
	void RedFinger_glFogxOES(GLenum pname, GLfixed param);
	void RedFinger_glFogxvOES(GLenum pname, const GLfixed* params);
	void RedFinger_glFrustumxOES(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
	void RedFinger_glGetClipPlanexOES(GLenum pname, GLfixed* eqn);
	void RedFinger_glGetClipPlanex(GLenum pname, GLfixed* eqn);
	void RedFinger_glGetFixedvOES(GLenum pname, GLfixed* params);
	void RedFinger_glGetLightxvOES(GLenum light, GLenum pname, GLfixed* params);
	void RedFinger_glGetMaterialxvOES(GLenum face, GLenum pname, GLfixed* params);
	void RedFinger_glGetTexEnvxvOES(GLenum env, GLenum pname, GLfixed* params);
	void RedFinger_glGetTexParameterxvOES(GLenum target, GLenum pname, GLfixed* params);
	void RedFinger_glLightModelxOES(GLenum pname, GLfixed param);
	void RedFinger_glLightModelxvOES(GLenum pname, const GLfixed* params);
	void RedFinger_glLightxOES(GLenum light, GLenum pname, GLfixed param);
	void RedFinger_glLightxvOES(GLenum light, GLenum pname, const GLfixed* params);
	void RedFinger_glLineWidthxOES(GLfixed width);
	void RedFinger_glLoadMatrixxOES(const GLfixed* m);
	void RedFinger_glMaterialxOES(GLenum face, GLenum pname, GLfixed param);
	void RedFinger_glMaterialxvOES(GLenum face, GLenum pname, const GLfixed* params);
	void RedFinger_glMultMatrixxOES(const GLfixed* m);
	void RedFinger_glMultiTexCoord4xOES(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
	void RedFinger_glNormal3xOES(GLfixed nx, GLfixed ny, GLfixed nz);
	void RedFinger_glOrthoxOES(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
	void RedFinger_glPointParameterxOES(GLenum pname, GLfixed param);
	void RedFinger_glPointParameterxvOES(GLenum pname, const GLfixed* params);
	void RedFinger_glPointSizexOES(GLfixed size);
	void RedFinger_glPolygonOffsetxOES(GLfixed factor, GLfixed units);
	void RedFinger_glRotatexOES(GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
	void RedFinger_glSampleCoveragexOES(GLclampx value, GLboolean invert);
	void RedFinger_glScalexOES(GLfixed x, GLfixed y, GLfixed z);
	void RedFinger_glTexEnvxOES(GLenum target, GLenum pname, GLfixed param);
	void RedFinger_glTexEnvxvOES(GLenum target, GLenum pname, const GLfixed* params);
	void RedFinger_glTexParameterxOES(GLenum target, GLenum pname, GLfixed param);
	void RedFinger_glTexParameterxvOES(GLenum target, GLenum pname, const GLfixed* params);
	void RedFinger_glTranslatexOES(GLfixed x, GLfixed y, GLfixed z);
	GLboolean RedFinger_glIsRenderbufferOES(GLuint renderbuffer);
	void RedFinger_glBindRenderbufferOES(GLenum target, GLuint renderbuffer);
	void RedFinger_glDeleteRenderbuffersOES(GLsizei n, const GLuint* renderbuffers);
	void RedFinger_glGenRenderbuffersOES(GLsizei n, GLuint* renderbuffers);
	void RedFinger_glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
	void RedFinger_glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint* params);
	GLboolean RedFinger_glIsFramebufferOES(GLuint framebuffer);
	void RedFinger_glBindFramebufferOES(GLenum target, GLuint framebuffer);
	void RedFinger_glDeleteFramebuffersOES(GLsizei n, const GLuint* framebuffers);
	void RedFinger_glGenFramebuffersOES(GLsizei n, GLuint* framebuffers);
	GLenum RedFinger_glCheckFramebufferStatusOES(GLenum target);
	void RedFinger_glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
	void RedFinger_glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
	void RedFinger_glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint* params);
	void RedFinger_glGenerateMipmapOES(GLenum target);
	void RedFinger_glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid** params);
	void RedFinger_glCurrentPaletteMatrixOES(GLuint matrixpaletteindex);
	void RedFinger_glLoadPaletteFromModelViewMatrixOES();
	void RedFinger_glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
	void RedFinger_glWeightPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer);
	GLbitfield RedFinger_glQueryMatrixxOES(GLfixed* mantissa, GLint* exponent);
	void RedFinger_glDepthRangefOES(GLclampf zNear, GLclampf zFar);
	void RedFinger_glFrustumfOES(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
	void RedFinger_glOrthofOES(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
	void RedFinger_glClipPlanefOES(GLenum plane, const GLfloat* equation);
	void RedFinger_glClipPlanefIMG(GLenum plane, const GLfloat* equation);
	void RedFinger_glGetClipPlanefOES(GLenum pname, GLfloat* eqn);
	void RedFinger_glClearDepthfOES(GLclampf depth);
	void RedFinger_glTexGenfOES(GLenum coord, GLenum pname, GLfloat param);
	void RedFinger_glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat* params);
	void RedFinger_glTexGeniOES(GLenum coord, GLenum pname, GLint param);
	void RedFinger_glTexGenivOES(GLenum coord, GLenum pname, const GLint* params);
	void RedFinger_glTexGenxOES(GLenum coord, GLenum pname, GLfixed param);
	void RedFinger_glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed* params);
	void RedFinger_glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat* params);
	void RedFinger_glGetTexGenivOES(GLenum coord, GLenum pname, GLint* params);
	void RedFinger_glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed* params);
	void RedFinger_glMultiDrawArraysSUN(GLenum mode, GLint* first, GLsizei* count, GLsizei primcount);
	void RedFinger_glMultiDrawElementsSUN(GLenum mode, const GLsizei* count, GLenum type, const GLvoid** indices, GLsizei primcount);
};

#endif


#undef GET_CONTEXT_client
#ifndef GET_CONTEXT_client
static gles_client_context_t::CONTEXT_ACCESSOR_TYPE *getCurrentContext_client = NULL;
void gles_client_context_t::setContextAccessor(CONTEXT_ACCESSOR_TYPE *f) { getCurrentContext_client = f; }
#define GET_CONTEXT_client gles_client_context_t * ctx = getCurrentContext_client() 
#endif

void RedFinger_glActiveTexture(GLenum texture)
{
	GET_CONTEXT_client; 
	 ctx->glActiveTexture(ctx, texture);
}

void RedFinger_glAttachShader(GLuint program, GLuint shader)
{
	GET_CONTEXT_client; 
	 ctx->glAttachShader(ctx, program, shader);
}

void RedFinger_glBindAttribLocation(GLuint program, GLuint index, const GLchar* name)
{
	GET_CONTEXT_client; 
	 ctx->glBindAttribLocation(ctx, program, index, name);
}

void RedFinger_glBindBuffer(GLenum target, GLuint buffer)
{
	GET_CONTEXT_client; 
	 ctx->glBindBuffer(ctx, target, buffer);
}

void RedFinger_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
	GET_CONTEXT_client; 
	 ctx->glBindFramebuffer(ctx, target, framebuffer);
}

void RedFinger_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
	GET_CONTEXT_client; 
	 ctx->glBindRenderbuffer(ctx, target, renderbuffer);
}

void RedFinger_glBindTexture(GLenum target, GLuint texture)
{
	GET_CONTEXT_client; 
	 ctx->glBindTexture(ctx, target, texture);
}

void RedFinger_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	GET_CONTEXT_client; 
	 ctx->glBlendColor(ctx, red, green, blue, alpha);
}

void RedFinger_glBlendEquation(GLenum mode)
{
	GET_CONTEXT_client; 
	 ctx->glBlendEquation(ctx, mode);
}

void RedFinger_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
	GET_CONTEXT_client; 
	 ctx->glBlendEquationSeparate(ctx, modeRGB, modeAlpha);
}

void RedFinger_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
	GET_CONTEXT_client; 
	 ctx->glBlendFunc(ctx, sfactor, dfactor);
}

void RedFinger_glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
	GET_CONTEXT_client; 
	 ctx->glBlendFuncSeparate(ctx, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

void RedFinger_glBufferData(GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage)
{
	GET_CONTEXT_client; 
	 ctx->glBufferData(ctx, target, size, data, usage);
}

void RedFinger_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data)
{
	GET_CONTEXT_client; 
	 ctx->glBufferSubData(ctx, target, offset, size, data);
}

GLenum RedFinger_glCheckFramebufferStatus(GLenum target)
{
	GET_CONTEXT_client; 
	 return ctx->glCheckFramebufferStatus(ctx, target);
}

void RedFinger_glClear(GLbitfield mask)
{
	GET_CONTEXT_client; 
	 ctx->glClear(ctx, mask);
}

void RedFinger_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	GET_CONTEXT_client; 
	 ctx->glClearColor(ctx, red, green, blue, alpha);
}

void RedFinger_glClearDepthf(GLclampf depth)
{
	GET_CONTEXT_client; 
	 ctx->glClearDepthf(ctx, depth);
}

void RedFinger_glClearStencil(GLint s)
{
	GET_CONTEXT_client; 
	 ctx->glClearStencil(ctx, s);
}

void RedFinger_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	GET_CONTEXT_client; 
	 ctx->glColorMask(ctx, red, green, blue, alpha);
}

void RedFinger_glCompileShader(GLuint shader)
{
	GET_CONTEXT_client; 
	 ctx->glCompileShader(ctx, shader);
}

void RedFinger_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT_client; 
	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glCompressedTexImage2D(ctx, target, level, internalformat, width, height, border, imageSize, data);
}

void RedFinger_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT_client; 
	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glCompressedTexSubImage2D(ctx, target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

void RedFinger_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
	GET_CONTEXT_client; 
	 ctx->glCopyTexImage2D(ctx, target, level, internalformat, x, y, width, height, border);
}

void RedFinger_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glCopyTexSubImage2D(ctx, target, level, xoffset, yoffset, x, y, width, height);
}

GLuint RedFinger_glCreateProgram()
{
	GET_CONTEXT_client; 
	 return ctx->glCreateProgram(ctx);
}

GLuint RedFinger_glCreateShader(GLenum type)
{
	GET_CONTEXT_client; 
	 return ctx->glCreateShader(ctx, type);
}

void RedFinger_glCullFace(GLenum mode)
{
	GET_CONTEXT_client; 
	 ctx->glCullFace(ctx, mode);
}

void RedFinger_glDeleteBuffers(GLsizei n, const GLuint* buffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteBuffers(ctx, n, buffers);
}

void RedFinger_glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteFramebuffers(ctx, n, framebuffers);
}

void RedFinger_glDeleteProgram(GLuint program)
{
	GET_CONTEXT_client; 
	 ctx->glDeleteProgram(ctx, program);
}

void RedFinger_glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteRenderbuffers(ctx, n, renderbuffers);
}

void RedFinger_glDeleteShader(GLuint shader)
{
	GET_CONTEXT_client; 
	 ctx->glDeleteShader(ctx, shader);
}

void RedFinger_glDeleteTextures(GLsizei n, const GLuint* textures)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteTextures(ctx, n, textures);
}

void RedFinger_glDepthFunc(GLenum func)
{
	GET_CONTEXT_client; 
	 ctx->glDepthFunc(ctx, func);
}

void RedFinger_glDepthMask(GLboolean flag)
{
	GET_CONTEXT_client; 
	 ctx->glDepthMask(ctx, flag);
}

void RedFinger_glDepthRangef(GLclampf zNear, GLclampf zFar)
{
	GET_CONTEXT_client; 
	 ctx->glDepthRangef(ctx, zNear, zFar);
}

void RedFinger_glDetachShader(GLuint program, GLuint shader)
{
	GET_CONTEXT_client; 
	 ctx->glDetachShader(ctx, program, shader);
}

void RedFinger_glDisable(GLenum cap)
{
	GET_CONTEXT_client; 
	 ctx->glDisable(ctx, cap);
}

void RedFinger_glDisableVertexAttribArray(GLuint index)
{
	GET_CONTEXT_client; 
	 ctx->glDisableVertexAttribArray(ctx, index);
}

void RedFinger_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
	GET_CONTEXT_client; 
	 ctx->glDrawArrays(ctx, mode, first, count);
}

void RedFinger_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid* indices)
{
		GET_CONTEXT_client; 
	ctx->glDrawElements(ctx, mode, count, type, indices);
}

void RedFinger_glEnable(GLenum cap)
{
	GET_CONTEXT_client; 
	 ctx->glEnable(ctx, cap);
}

void RedFinger_glEnableVertexAttribArray(GLuint index)
{
	GET_CONTEXT_client; 
	 ctx->glEnableVertexAttribArray(ctx, index);
}

void RedFinger_glFinish()
{
	GET_CONTEXT_client; 
	 ctx->glFinish(ctx);
}

void RedFinger_glFlush()
{
	GET_CONTEXT_client; 
	 ctx->glFlush(ctx);
}

void RedFinger_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	GET_CONTEXT_client; 
	 ctx->glFramebufferRenderbuffer(ctx, target, attachment, renderbuffertarget, renderbuffer);
}

void RedFinger_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	GET_CONTEXT_client; 
	 ctx->glFramebufferTexture2D(ctx, target, attachment, textarget, texture, level);
}

void RedFinger_glFrontFace(GLenum mode)
{
	GET_CONTEXT_client; 
	 ctx->glFrontFace(ctx, mode);
}

void RedFinger_glGenBuffers(GLsizei n, GLuint* buffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenBuffers(ctx, n, buffers);
}

void RedFinger_glGenerateMipmap(GLenum target)
{
	GET_CONTEXT_client; 
	 ctx->glGenerateMipmap(ctx, target);
}

void RedFinger_glGenFramebuffers(GLsizei n, GLuint* framebuffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenFramebuffers(ctx, n, framebuffers);
}

void RedFinger_glGenRenderbuffers(GLsizei n, GLuint* renderbuffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenRenderbuffers(ctx, n, renderbuffers);
}

void RedFinger_glGenTextures(GLsizei n, GLuint* textures)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenTextures(ctx, n, textures);
}

void RedFinger_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{
	GET_CONTEXT_client; 
	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetActiveAttrib(ctx, program, index, bufsize, length, size, type, name);
}

void RedFinger_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufsize, GLsizei* length, GLint* size, GLenum* type, GLchar* name)
{
	GET_CONTEXT_client; 
	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetActiveUniform(ctx, program, index, bufsize, length, size, type, name);
}

void RedFinger_glGetAttachedShaders(GLuint program, GLsizei maxcount, GLsizei* count, GLuint* shaders)
{
	GET_CONTEXT_client; 
	 ctx->glGetAttachedShaders(ctx, program, maxcount, count, shaders);
}

int RedFinger_glGetAttribLocation(GLuint program, const GLchar* name)
{
	GET_CONTEXT_client; 
	 return ctx->glGetAttribLocation(ctx, program, name);
}

void RedFinger_glGetBooleanv(GLenum pname, GLboolean* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetBooleanv(ctx, pname, params);
}

void RedFinger_glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetBufferParameteriv(ctx, target, pname, params);
}

GLenum RedFinger_glGetError()
{
	GET_CONTEXT_client; 
	 return ctx->glGetError(ctx);
}

void RedFinger_glGetFloatv(GLenum pname, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetFloatv(ctx, pname, params);
}

void RedFinger_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetFramebufferAttachmentParameteriv(ctx, target, attachment, pname, params);
}

void RedFinger_glGetIntegerv(GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetIntegerv(ctx, pname, params);
}

void RedFinger_glGetProgramiv(GLuint program, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetProgramiv(ctx, program, pname, params);
}

void RedFinger_glGetProgramInfoLog(GLuint program, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{
	GET_CONTEXT_client; 
	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetProgramInfoLog(ctx, program, bufsize, length, infolog);
}

void RedFinger_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetRenderbufferParameteriv(ctx, target, pname, params);
}

void RedFinger_glGetShaderiv(GLuint shader, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetShaderiv(ctx, shader, pname, params);
}

void RedFinger_glGetShaderInfoLog(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* infolog)
{
	GET_CONTEXT_client; 
	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetShaderInfoLog(ctx, shader, bufsize, length, infolog);
}

void RedFinger_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint* range, GLint* precision)
{
	GET_CONTEXT_client; 
	 ctx->glGetShaderPrecisionFormat(ctx, shadertype, precisiontype, range, precision);
}

void RedFinger_glGetShaderSource(GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source)
{
	GET_CONTEXT_client; 
	 if(bufsize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetShaderSource(ctx, shader, bufsize, length, source);
}

const GLubyte* RedFinger_glGetString(GLenum name)
{
		GET_CONTEXT_client; 
	return ctx->glGetString(ctx, name);
}

void RedFinger_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexParameterfv(ctx, target, pname, params);
}

void RedFinger_glGetTexParameteriv(GLenum target, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexParameteriv(ctx, target, pname, params);
}

void RedFinger_glGetUniformfv(GLuint program, GLint location, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetUniformfv(ctx, program, location, params);
}

void RedFinger_glGetUniformiv(GLuint program, GLint location, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetUniformiv(ctx, program, location, params);
}

int RedFinger_glGetUniformLocation(GLuint program, const GLchar* name)
{
	GET_CONTEXT_client; 
	 return ctx->glGetUniformLocation(ctx, program, name);
}

void RedFinger_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetVertexAttribfv(ctx, index, pname, params);
}

void RedFinger_glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetVertexAttribiv(ctx, index, pname, params);
}

void RedFinger_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid** pointer)
{
		GET_CONTEXT_client; 
	ctx->glGetVertexAttribPointerv(ctx, index, pname, pointer);
}

void RedFinger_glHint(GLenum target, GLenum mode)
{
	GET_CONTEXT_client; 
	 ctx->glHint(ctx, target, mode);
}

GLboolean RedFinger_glIsBuffer(GLuint buffer)
{
	GET_CONTEXT_client; 
	 return ctx->glIsBuffer(ctx, buffer);
}

GLboolean RedFinger_glIsEnabled(GLenum cap)
{
	GET_CONTEXT_client; 
	 return ctx->glIsEnabled(ctx, cap);
}

GLboolean RedFinger_glIsFramebuffer(GLuint framebuffer)
{
	GET_CONTEXT_client; 
	 return ctx->glIsFramebuffer(ctx, framebuffer);
}

GLboolean RedFinger_glIsProgram(GLuint program)
{
	GET_CONTEXT_client; 
	 return ctx->glIsProgram(ctx, program);
}

GLboolean RedFinger_glIsRenderbuffer(GLuint renderbuffer)
{
	GET_CONTEXT_client; 
	 return ctx->glIsRenderbuffer(ctx, renderbuffer);
}

GLboolean RedFinger_glIsShader(GLuint shader)
{
	GET_CONTEXT_client; 
	 return ctx->glIsShader(ctx, shader);
}

GLboolean RedFinger_glIsTexture(GLuint texture)
{
	GET_CONTEXT_client; 
	 return ctx->glIsTexture(ctx, texture);
}

void RedFinger_glLineWidth(GLfloat width)
{
	GET_CONTEXT_client; 
	 ctx->glLineWidth(ctx, width);
}

void RedFinger_glLinkProgram(GLuint program)
{
	GET_CONTEXT_client; 
	 ctx->glLinkProgram(ctx, program);
}

void RedFinger_glPixelStorei(GLenum pname, GLint param)
{
	GET_CONTEXT_client; 
	 ctx->glPixelStorei(ctx, pname, param);
}

void RedFinger_glPolygonOffset(GLfloat factor, GLfloat units)
{
	GET_CONTEXT_client; 
	 ctx->glPolygonOffset(ctx, factor, units);
}

void RedFinger_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels)
{
	GET_CONTEXT_client; 
	 ctx->glReadPixels(ctx, x, y, width, height, format, type, pixels);
}

void RedFinger_glReleaseShaderCompiler()
{
	GET_CONTEXT_client; 
	 ctx->glReleaseShaderCompiler(ctx);
}

void RedFinger_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glRenderbufferStorage(ctx, target, internalformat, width, height);
}

void RedFinger_glSampleCoverage(GLclampf value, GLboolean invert)
{
	GET_CONTEXT_client; 
	 ctx->glSampleCoverage(ctx, value, invert);
}

void RedFinger_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glScissor(ctx, x, y, width, height);
}

void RedFinger_glShaderBinary(GLsizei n, const GLuint* shaders, GLenum binaryformat, const GLvoid* binary, GLsizei length)
{
	GET_CONTEXT_client; 
	 ctx->glShaderBinary(ctx, n, shaders, binaryformat, binary, length);
}

void RedFinger_glShaderSource(GLuint shader, GLsizei count, const GLchar*const* string, const GLint* length)
{
		GET_CONTEXT_client; 
	ctx->glShaderSource(ctx, shader, count, string, length);
}

void RedFinger_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
	GET_CONTEXT_client; 
	 ctx->glStencilFunc(ctx, func, ref, mask);
}

void RedFinger_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
	GET_CONTEXT_client; 
	 ctx->glStencilFuncSeparate(ctx, face, func, ref, mask);
}

void RedFinger_glStencilMask(GLuint mask)
{
	GET_CONTEXT_client; 
	 ctx->glStencilMask(ctx, mask);
}

void RedFinger_glStencilMaskSeparate(GLenum face, GLuint mask)
{
	GET_CONTEXT_client; 
	 ctx->glStencilMaskSeparate(ctx, face, mask);
}

void RedFinger_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
	GET_CONTEXT_client; 
	 ctx->glStencilOp(ctx, fail, zfail, zpass);
}

void RedFinger_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
	GET_CONTEXT_client; 
	 ctx->glStencilOpSeparate(ctx, face, fail, zfail, zpass);
}

void RedFinger_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{
	GET_CONTEXT_client; 
	 ctx->glTexImage2D(ctx, target, level, internalformat, width, height, border, format, type, pixels);
}

void RedFinger_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
	GET_CONTEXT_client; 
	 ctx->glTexParameterf(ctx, target, pname, param);
}

void RedFinger_glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexParameterfv(ctx, target, pname, params);
}

void RedFinger_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
	GET_CONTEXT_client; 
	 ctx->glTexParameteri(ctx, target, pname, param);
}

void RedFinger_glTexParameteriv(GLenum target, GLenum pname, const GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexParameteriv(ctx, target, pname, params);
}

void RedFinger_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid* pixels)
{
	GET_CONTEXT_client; 
	 ctx->glTexSubImage2D(ctx, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

void RedFinger_glUniform1f(GLint location, GLfloat x)
{
	GET_CONTEXT_client; 
	 ctx->glUniform1f(ctx, location, x);
}

void RedFinger_glUniform1fv(GLint location, GLsizei count, const GLfloat* v)
{
	GET_CONTEXT_client; 
	 ctx->glUniform1fv(ctx, location, count, v);
}

void RedFinger_glUniform1i(GLint location, GLint x)
{
	GET_CONTEXT_client; 
	 ctx->glUniform1i(ctx, location, x);
}

void RedFinger_glUniform1iv(GLint location, GLsizei count, const GLint* v)
{
	GET_CONTEXT_client; 
	 ctx->glUniform1iv(ctx, location, count, v);
}

void RedFinger_glUniform2f(GLint location, GLfloat x, GLfloat y)
{
	GET_CONTEXT_client; 
	 ctx->glUniform2f(ctx, location, x, y);
}

void RedFinger_glUniform2fv(GLint location, GLsizei count, const GLfloat* v)
{
	GET_CONTEXT_client; 
	 ctx->glUniform2fv(ctx, location, count, v);
}

void RedFinger_glUniform2i(GLint location, GLint x, GLint y)
{
	GET_CONTEXT_client; 
	 ctx->glUniform2i(ctx, location, x, y);
}

void RedFinger_glUniform2iv(GLint location, GLsizei count, const GLint* v)
{
	GET_CONTEXT_client; 
	 ctx->glUniform2iv(ctx, location, count, v);
}

void RedFinger_glUniform3f(GLint location, GLfloat x, GLfloat y, GLfloat z)
{
	GET_CONTEXT_client; 
	 ctx->glUniform3f(ctx, location, x, y, z);
}

void RedFinger_glUniform3fv(GLint location, GLsizei count, const GLfloat* v)
{
	GET_CONTEXT_client; 
	 ctx->glUniform3fv(ctx, location, count, v);
}

void RedFinger_glUniform3i(GLint location, GLint x, GLint y, GLint z)
{
	GET_CONTEXT_client; 
	 ctx->glUniform3i(ctx, location, x, y, z);
}

void RedFinger_glUniform3iv(GLint location, GLsizei count, const GLint* v)
{
	GET_CONTEXT_client; 
	 ctx->glUniform3iv(ctx, location, count, v);
}

void RedFinger_glUniform4f(GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	GET_CONTEXT_client; 
	 ctx->glUniform4f(ctx, location, x, y, z, w);
}

void RedFinger_glUniform4fv(GLint location, GLsizei count, const GLfloat* v)
{
	GET_CONTEXT_client; 
	 ctx->glUniform4fv(ctx, location, count, v);
}

void RedFinger_glUniform4i(GLint location, GLint x, GLint y, GLint z, GLint w)
{
	GET_CONTEXT_client; 
	 ctx->glUniform4i(ctx, location, x, y, z, w);
}

void RedFinger_glUniform4iv(GLint location, GLsizei count, const GLint* v)
{
	GET_CONTEXT_client; 
	 ctx->glUniform4iv(ctx, location, count, v);
}

void RedFinger_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniformMatrix2fv(ctx, location, count, transpose, value);
}

void RedFinger_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniformMatrix3fv(ctx, location, count, transpose, value);
}

void RedFinger_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniformMatrix4fv(ctx, location, count, transpose, value);
}

void RedFinger_glUseProgram(GLuint program)
{
	GET_CONTEXT_client; 
	 ctx->glUseProgram(ctx, program);
}

void RedFinger_glValidateProgram(GLuint program)
{
	GET_CONTEXT_client; 
	 ctx->glValidateProgram(ctx, program);
}

void RedFinger_glVertexAttrib1f(GLuint indx, GLfloat x)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttrib1f(ctx, indx, x);
}

void RedFinger_glVertexAttrib1fv(GLuint indx, const GLfloat* values)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttrib1fv(ctx, indx, values);
}

void RedFinger_glVertexAttrib2f(GLuint indx, GLfloat x, GLfloat y)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttrib2f(ctx, indx, x, y);
}

void RedFinger_glVertexAttrib2fv(GLuint indx, const GLfloat* values)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttrib2fv(ctx, indx, values);
}

void RedFinger_glVertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttrib3f(ctx, indx, x, y, z);
}

void RedFinger_glVertexAttrib3fv(GLuint indx, const GLfloat* values)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttrib3fv(ctx, indx, values);
}

void RedFinger_glVertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttrib4f(ctx, indx, x, y, z, w);
}

void RedFinger_glVertexAttrib4fv(GLuint indx, const GLfloat* values)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttrib4fv(ctx, indx, values);
}

void RedFinger_glVertexAttribPointer(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* ptr)
{
		GET_CONTEXT_client; 
	ctx->glVertexAttribPointer(ctx, indx, size, type, normalized, stride, ptr);
}

void RedFinger_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glViewport(ctx, x, y, width, height);
}

void RedFinger_glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image)
{
	GET_CONTEXT_client; 
	 ctx->glEGLImageTargetTexture2DOES(ctx, target, image);
}

void RedFinger_glEGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image)
{
	GET_CONTEXT_client; 
	 ctx->glEGLImageTargetRenderbufferStorageOES(ctx, target, image);
}

void RedFinger_glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, GLvoid* binary)
{
	GET_CONTEXT_client; 
	 ctx->glGetProgramBinaryOES(ctx, program, bufSize, length, binaryFormat, binary);
}

void RedFinger_glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid* binary, GLint length)
{
	GET_CONTEXT_client; 
	 ctx->glProgramBinaryOES(ctx, program, binaryFormat, binary, length);
}

void* RedFinger_glMapBufferOES(GLenum target, GLenum access)
{
	GET_CONTEXT_client; 
	 return ctx->glMapBufferOES(ctx, target, access);
}

GLboolean RedFinger_glUnmapBufferOES(GLenum target)
{
	GET_CONTEXT_client; 
	 return ctx->glUnmapBufferOES(ctx, target);
}

void RedFinger_glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{
	GET_CONTEXT_client; 
	 ctx->glTexImage3DOES(ctx, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

void RedFinger_glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels)
{
	GET_CONTEXT_client; 
	 ctx->glTexSubImage3DOES(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

void RedFinger_glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glCopyTexSubImage3DOES(ctx, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

void RedFinger_glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT_client; 
	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glCompressedTexImage3DOES(ctx, target, level, internalformat, width, height, depth, border, imageSize, data);
}

void RedFinger_glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT_client; 
	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glCompressedTexSubImage3DOES(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

void RedFinger_glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
	GET_CONTEXT_client; 
	 ctx->glFramebufferTexture3DOES(ctx, target, attachment, textarget, texture, level, zoffset);
}

void RedFinger_glBindVertexArrayOES(GLuint array)
{
	GET_CONTEXT_client; 
	 ctx->glBindVertexArrayOES(ctx, array);
}

void RedFinger_glDeleteVertexArraysOES(GLsizei n, const GLuint* arrays)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteVertexArraysOES(ctx, n, arrays);
}

void RedFinger_glGenVertexArraysOES(GLsizei n, GLuint* arrays)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenVertexArraysOES(ctx, n, arrays);
}

GLboolean RedFinger_glIsVertexArrayOES(GLuint array)
{
	GET_CONTEXT_client; 
	 return ctx->glIsVertexArrayOES(ctx, array);
}

void RedFinger_glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum* attachments)
{
	GET_CONTEXT_client; 
	 ctx->glDiscardFramebufferEXT(ctx, target, numAttachments, attachments);
}

void RedFinger_glMultiDrawArraysEXT(GLenum mode, const GLint* first, const GLsizei* count, GLsizei primcount)
{
	GET_CONTEXT_client; 
	 ctx->glMultiDrawArraysEXT(ctx, mode, first, count, primcount);
}

void RedFinger_glMultiDrawElementsEXT(GLenum mode, const GLsizei* count, GLenum type, const GLvoid*const* indices, GLsizei primcount)
{
	GET_CONTEXT_client; 
	 ctx->glMultiDrawElementsEXT(ctx, mode, count, type, indices, primcount);
}

void RedFinger_glGetPerfMonitorGroupsAMD(GLint* numGroups, GLsizei groupsSize, GLuint* groups)
{
	GET_CONTEXT_client; 
	 ctx->glGetPerfMonitorGroupsAMD(ctx, numGroups, groupsSize, groups);
}

void RedFinger_glGetPerfMonitorCountersAMD(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters)
{
	GET_CONTEXT_client; 
	 ctx->glGetPerfMonitorCountersAMD(ctx, group, numCounters, maxActiveCounters, counterSize, counters);
}

void RedFinger_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString)
{
	GET_CONTEXT_client; 
	 ctx->glGetPerfMonitorGroupStringAMD(ctx, group, bufSize, length, groupString);
}

void RedFinger_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString)
{
	GET_CONTEXT_client; 
	 ctx->glGetPerfMonitorCounterStringAMD(ctx, group, counter, bufSize, length, counterString);
}

void RedFinger_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid* data)
{
	GET_CONTEXT_client; 
	 ctx->glGetPerfMonitorCounterInfoAMD(ctx, group, counter, pname, data);
}

void RedFinger_glGenPerfMonitorsAMD(GLsizei n, GLuint* monitors)
{
	GET_CONTEXT_client; 
	 ctx->glGenPerfMonitorsAMD(ctx, n, monitors);
}

void RedFinger_glDeletePerfMonitorsAMD(GLsizei n, GLuint* monitors)
{
	GET_CONTEXT_client; 
	 ctx->glDeletePerfMonitorsAMD(ctx, n, monitors);
}

void RedFinger_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* countersList)
{
	GET_CONTEXT_client; 
	 ctx->glSelectPerfMonitorCountersAMD(ctx, monitor, enable, group, numCounters, countersList);
}

void RedFinger_glBeginPerfMonitorAMD(GLuint monitor)
{
	GET_CONTEXT_client; 
	 ctx->glBeginPerfMonitorAMD(ctx, monitor);
}

void RedFinger_glEndPerfMonitorAMD(GLuint monitor)
{
	GET_CONTEXT_client; 
	 ctx->glEndPerfMonitorAMD(ctx, monitor);
}

void RedFinger_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten)
{
	GET_CONTEXT_client; 
	 ctx->glGetPerfMonitorCounterDataAMD(ctx, monitor, pname, dataSize, data, bytesWritten);
}

void RedFinger_glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glRenderbufferStorageMultisampleIMG(ctx, target, samples, internalformat, width, height);
}

void RedFinger_glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
	GET_CONTEXT_client; 
	 ctx->glFramebufferTexture2DMultisampleIMG(ctx, target, attachment, textarget, texture, level, samples);
}

void RedFinger_glDeleteFencesNV(GLsizei n, const GLuint* fences)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteFencesNV(ctx, n, fences);
}

void RedFinger_glGenFencesNV(GLsizei n, GLuint* fences)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenFencesNV(ctx, n, fences);
}

GLboolean RedFinger_glIsFenceNV(GLuint fence)
{
	GET_CONTEXT_client; 
	 return ctx->glIsFenceNV(ctx, fence);
}

GLboolean RedFinger_glTestFenceNV(GLuint fence)
{
	GET_CONTEXT_client; 
	 return ctx->glTestFenceNV(ctx, fence);
}

void RedFinger_glGetFenceivNV(GLuint fence, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetFenceivNV(ctx, fence, pname, params);
}

void RedFinger_glFinishFenceNV(GLuint fence)
{
	GET_CONTEXT_client; 
	 ctx->glFinishFenceNV(ctx, fence);
}

void RedFinger_glSetFenceNV(GLuint fence, GLenum condition)
{
	GET_CONTEXT_client; 
	 ctx->glSetFenceNV(ctx, fence, condition);
}

void RedFinger_glCoverageMaskNV(GLboolean mask)
{
	GET_CONTEXT_client; 
	 ctx->glCoverageMaskNV(ctx, mask);
}

void RedFinger_glCoverageOperationNV(GLenum operation)
{
	GET_CONTEXT_client; 
	 ctx->glCoverageOperationNV(ctx, operation);
}

void RedFinger_glGetDriverControlsQCOM(GLint* num, GLsizei size, GLuint* driverControls)
{
	GET_CONTEXT_client; 
	 ctx->glGetDriverControlsQCOM(ctx, num, size, driverControls);
}

void RedFinger_glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar* driverControlString)
{
	GET_CONTEXT_client; 
	 ctx->glGetDriverControlStringQCOM(ctx, driverControl, bufSize, length, driverControlString);
}

void RedFinger_glEnableDriverControlQCOM(GLuint driverControl)
{
	GET_CONTEXT_client; 
	 ctx->glEnableDriverControlQCOM(ctx, driverControl);
}

void RedFinger_glDisableDriverControlQCOM(GLuint driverControl)
{
	GET_CONTEXT_client; 
	 ctx->glDisableDriverControlQCOM(ctx, driverControl);
}

void RedFinger_glExtGetTexturesQCOM(GLuint* textures, GLint maxTextures, GLint* numTextures)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetTexturesQCOM(ctx, textures, maxTextures, numTextures);
}

void RedFinger_glExtGetBuffersQCOM(GLuint* buffers, GLint maxBuffers, GLint* numBuffers)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetBuffersQCOM(ctx, buffers, maxBuffers, numBuffers);
}

void RedFinger_glExtGetRenderbuffersQCOM(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetRenderbuffersQCOM(ctx, renderbuffers, maxRenderbuffers, numRenderbuffers);
}

void RedFinger_glExtGetFramebuffersQCOM(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetFramebuffersQCOM(ctx, framebuffers, maxFramebuffers, numFramebuffers);
}

void RedFinger_glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetTexLevelParameterivQCOM(ctx, texture, face, level, pname, params);
}

void RedFinger_glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param)
{
	GET_CONTEXT_client; 
	 ctx->glExtTexObjectStateOverrideiQCOM(ctx, target, pname, param);
}

void RedFinger_glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid* texels)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetTexSubImageQCOM(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
}

void RedFinger_glExtGetBufferPointervQCOM(GLenum target, GLvoidptr* params)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetBufferPointervQCOM(ctx, target, params);
}

void RedFinger_glExtGetShadersQCOM(GLuint* shaders, GLint maxShaders, GLint* numShaders)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetShadersQCOM(ctx, shaders, maxShaders, numShaders);
}

void RedFinger_glExtGetProgramsQCOM(GLuint* programs, GLint maxPrograms, GLint* numPrograms)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetProgramsQCOM(ctx, programs, maxPrograms, numPrograms);
}

GLboolean RedFinger_glExtIsProgramBinaryQCOM(GLuint program)
{
	GET_CONTEXT_client; 
	 return ctx->glExtIsProgramBinaryQCOM(ctx, program);
}

void RedFinger_glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar* source, GLint* length)
{
	GET_CONTEXT_client; 
	 ctx->glExtGetProgramBinarySourceQCOM(ctx, program, shadertype, source, length);
}

void RedFinger_glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask)
{
	GET_CONTEXT_client; 
	 ctx->glStartTilingQCOM(ctx, x, y, width, height, preserveMask);
}

void RedFinger_glEndTilingQCOM(GLbitfield preserveMask)
{
	GET_CONTEXT_client; 
	 ctx->glEndTilingQCOM(ctx, preserveMask);
}

void RedFinger_glVertexAttribPointerData(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribPointerData(ctx, indx, size, type, normalized, stride, data, datalen);
}

void RedFinger_glVertexAttribPointerOffset(GLuint indx, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribPointerOffset(ctx, indx, size, type, normalized, stride, offset);
}

void RedFinger_glDrawElementsOffset(GLenum mode, GLsizei count, GLenum type, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glDrawElementsOffset(ctx, mode, count, type, offset);
}

void RedFinger_glDrawElementsData(GLenum mode, GLsizei count, GLenum type, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glDrawElementsData(ctx, mode, count, type, data, datalen);
}

void RedFinger_glGetCompressedTextureFormats(int count, GLint* formats)
{
	GET_CONTEXT_client; 
	 ctx->glGetCompressedTextureFormats(ctx, count, formats);
}

void RedFinger_glShaderString(GLuint shader, const GLchar* string, GLsizei len)
{
	GET_CONTEXT_client; 
	 ctx->glShaderString(ctx, shader, string, len);
}

int RedFinger_glFinishRoundTrip()
{
	GET_CONTEXT_client; 
	 return ctx->glFinishRoundTrip(ctx);
}

void RedFinger_glGenVertexArrays(GLsizei n, GLuint* arrays)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenVertexArrays(ctx, n, arrays);
}

void RedFinger_glBindVertexArray(GLuint array)
{
	GET_CONTEXT_client; 
	 ctx->glBindVertexArray(ctx, array);
}

void RedFinger_glDeleteVertexArrays(GLsizei n, const GLuint* arrays)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteVertexArrays(ctx, n, arrays);
}

GLboolean RedFinger_glIsVertexArray(GLuint array)
{
	GET_CONTEXT_client; 
	 return ctx->glIsVertexArray(ctx, array);
}

void* RedFinger_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
		GET_CONTEXT_client; 
	return ctx->glMapBufferRange(ctx, target, offset, length, access);
}

GLboolean RedFinger_glUnmapBuffer(GLenum target)
{
		GET_CONTEXT_client; 
	return ctx->glUnmapBuffer(ctx, target);
}

void RedFinger_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
		GET_CONTEXT_client; 
	ctx->glFlushMappedBufferRange(ctx, target, offset, length);
}

void RedFinger_glMapBufferRangeAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* mapped)
{
	GET_CONTEXT_client; 
	 ctx->glMapBufferRangeAEMU(ctx, target, offset, length, access, mapped);
}

void RedFinger_glUnmapBufferAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer, GLboolean* out_res)
{
	GET_CONTEXT_client; 
	 ctx->glUnmapBufferAEMU(ctx, target, offset, length, access, guest_buffer, out_res);
}

void RedFinger_glFlushMappedBufferRangeAEMU(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access, void* guest_buffer)
{
	GET_CONTEXT_client; 
	 ctx->glFlushMappedBufferRangeAEMU(ctx, target, offset, length, access, guest_buffer);
}

void RedFinger_glReadPixelsOffsetAEMU(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glReadPixelsOffsetAEMU(ctx, x, y, width, height, format, type, offset);
}

void RedFinger_glCompressedTexImage2DOffsetAEMU(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glCompressedTexImage2DOffsetAEMU(ctx, target, level, internalformat, width, height, border, imageSize, offset);
}

void RedFinger_glCompressedTexSubImage2DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glCompressedTexSubImage2DOffsetAEMU(ctx, target, level, xoffset, yoffset, width, height, format, imageSize, offset);
}

void RedFinger_glTexImage2DOffsetAEMU(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glTexImage2DOffsetAEMU(ctx, target, level, internalformat, width, height, border, format, type, offset);
}

void RedFinger_glTexSubImage2DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glTexSubImage2DOffsetAEMU(ctx, target, level, xoffset, yoffset, width, height, format, type, offset);
}

void RedFinger_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
	GET_CONTEXT_client; 
	 ctx->glBindBufferRange(ctx, target, index, buffer, offset, size);
}

void RedFinger_glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
	GET_CONTEXT_client; 
	 ctx->glBindBufferBase(ctx, target, index, buffer);
}

void RedFinger_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
	GET_CONTEXT_client; 
	 ctx->glCopyBufferSubData(ctx, readtarget, writetarget, readoffset, writeoffset, size);
}

void RedFinger_glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint* value)
{
	GET_CONTEXT_client; 
	 ctx->glClearBufferiv(ctx, buffer, drawBuffer, value);
}

void RedFinger_glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint* value)
{
	GET_CONTEXT_client; 
	 ctx->glClearBufferuiv(ctx, buffer, drawBuffer, value);
}

void RedFinger_glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glClearBufferfv(ctx, buffer, drawBuffer, value);
}

void RedFinger_glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil)
{
	GET_CONTEXT_client; 
	 ctx->glClearBufferfi(ctx, buffer, drawBuffer, depth, stencil);
}

void RedFinger_glGetBufferParameteri64v(GLenum target, GLenum value, GLint64* data)
{
	GET_CONTEXT_client; 
	 ctx->glGetBufferParameteri64v(ctx, target, value, data);
}

void RedFinger_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid** params)
{
	GET_CONTEXT_client; 
	 ctx->glGetBufferPointerv(ctx, target, pname, params);
}

void RedFinger_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
	GET_CONTEXT_client; 
	 ctx->glUniformBlockBinding(ctx, program, uniformBlockIndex, uniformBlockBinding);
}

GLuint RedFinger_glGetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName)
{
	GET_CONTEXT_client; 
	 return ctx->glGetUniformBlockIndex(ctx, program, uniformBlockName);
}

void RedFinger_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar** var3, GLuint* uniformIndices)
{
		GET_CONTEXT_client; 
	ctx->glGetUniformIndices(ctx, program, uniformCount, var3, uniformIndices);
}

void RedFinger_glGetUniformIndicesAEMU(GLuint program, GLsizei uniformCount, const GLchar* packedUniformNames, GLsizei packedLen, GLuint* uniformIndices)
{
	GET_CONTEXT_client; 
	 ctx->glGetUniformIndicesAEMU(ctx, program, uniformCount, packedUniformNames, packedLen, uniformIndices);
}

void RedFinger_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetActiveUniformBlockiv(ctx, program, uniformBlockIndex, pname, params);
}

void RedFinger_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName)
{
	GET_CONTEXT_client; 
	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetActiveUniformBlockName(ctx, program, uniformBlockIndex, bufSize, length, uniformBlockName);
}

void RedFinger_glUniform1ui(GLint location, GLuint v0)
{
	GET_CONTEXT_client; 
	 ctx->glUniform1ui(ctx, location, v0);
}

void RedFinger_glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
	GET_CONTEXT_client; 
	 ctx->glUniform2ui(ctx, location, v0, v1);
}

void RedFinger_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
	GET_CONTEXT_client; 
	 ctx->glUniform3ui(ctx, location, v0, v1, v2);
}

void RedFinger_glUniform4ui(GLint location, GLint v0, GLuint v1, GLuint v2, GLuint v3)
{
	GET_CONTEXT_client; 
	 ctx->glUniform4ui(ctx, location, v0, v1, v2, v3);
}

void RedFinger_glUniform1uiv(GLint location, GLsizei count, const GLuint* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniform1uiv(ctx, location, count, value);
}

void RedFinger_glUniform2uiv(GLint location, GLsizei count, const GLuint* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniform2uiv(ctx, location, count, value);
}

void RedFinger_glUniform3uiv(GLint location, GLsizei count, const GLuint* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniform3uiv(ctx, location, count, value);
}

void RedFinger_glUniform4uiv(GLint location, GLsizei count, const GLuint* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniform4uiv(ctx, location, count, value);
}

void RedFinger_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniformMatrix2x3fv(ctx, location, count, transpose, value);
}

void RedFinger_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniformMatrix3x2fv(ctx, location, count, transpose, value);
}

void RedFinger_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniformMatrix2x4fv(ctx, location, count, transpose, value);
}

void RedFinger_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniformMatrix4x2fv(ctx, location, count, transpose, value);
}

void RedFinger_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniformMatrix3x4fv(ctx, location, count, transpose, value);
}

void RedFinger_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glUniformMatrix4x3fv(ctx, location, count, transpose, value);
}

void RedFinger_glGetUniformuiv(GLuint program, GLint location, GLuint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetUniformuiv(ctx, program, location, params);
}

void RedFinger_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetActiveUniformsiv(ctx, program, uniformCount, uniformIndices, pname, params);
}

void RedFinger_glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribI4i(ctx, index, v0, v1, v2, v3);
}

void RedFinger_glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribI4ui(ctx, index, v0, v1, v2, v3);
}

void RedFinger_glVertexAttribI4iv(GLuint index, const GLint* v)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribI4iv(ctx, index, v);
}

void RedFinger_glVertexAttribI4uiv(GLuint index, const GLuint* v)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribI4uiv(ctx, index, v);
}

void RedFinger_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid* pointer)
{
		GET_CONTEXT_client; 
	ctx->glVertexAttribIPointer(ctx, index, size, type, stride, pointer);
}

void RedFinger_glVertexAttribIPointerOffsetAEMU(GLuint index, GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribIPointerOffsetAEMU(ctx, index, size, type, stride, offset);
}

void RedFinger_glVertexAttribIPointerDataAEMU(GLuint index, GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribIPointerDataAEMU(ctx, index, size, type, stride, data, datalen);
}

void RedFinger_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetVertexAttribIiv(ctx, index, pname, params);
}

void RedFinger_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetVertexAttribIuiv(ctx, index, pname, params);
}

void RedFinger_glVertexAttribDivisor(GLuint index, GLuint divisor)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribDivisor(ctx, index, divisor);
}

void RedFinger_glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
{
	GET_CONTEXT_client; 
	 ctx->glDrawArraysInstanced(ctx, mode, first, count, primcount);
}

void RedFinger_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount)
{
		GET_CONTEXT_client; 
	ctx->glDrawElementsInstanced(ctx, mode, count, type, indices, primcount);
}

void RedFinger_glDrawElementsInstancedDataAEMU(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount, GLsizei datalen)
{
	GET_CONTEXT_client; 
	 ctx->glDrawElementsInstancedDataAEMU(ctx, mode, count, type, indices, primcount, datalen);
}

void RedFinger_glDrawElementsInstancedOffsetAEMU(GLenum mode, GLsizei count, GLenum type, GLuint offset, GLsizei primcount)
{
	GET_CONTEXT_client; 
	 ctx->glDrawElementsInstancedOffsetAEMU(ctx, mode, count, type, offset, primcount);
}

void RedFinger_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices)
{
		GET_CONTEXT_client; 
	ctx->glDrawRangeElements(ctx, mode, start, end, count, type, indices);
}

void RedFinger_glDrawRangeElementsDataAEMU(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid* indices, GLsizei datalen)
{
	GET_CONTEXT_client; 
	 ctx->glDrawRangeElementsDataAEMU(ctx, mode, start, end, count, type, indices, datalen);
}

void RedFinger_glDrawRangeElementsOffsetAEMU(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glDrawRangeElementsOffsetAEMU(ctx, mode, start, end, count, type, offset);
}

GLsync RedFinger_glFenceSync(GLenum condition, GLbitfield flags)
{
		GET_CONTEXT_client; 
	return ctx->glFenceSync(ctx, condition, flags);
}

GLenum RedFinger_glClientWaitSync(GLsync wait_on, GLbitfield flags, GLuint64 timeout)
{
		GET_CONTEXT_client; 
	return ctx->glClientWaitSync(ctx, wait_on, flags, timeout);
}

void RedFinger_glWaitSync(GLsync wait_on, GLbitfield flags, GLuint64 timeout)
{
		GET_CONTEXT_client; 
	ctx->glWaitSync(ctx, wait_on, flags, timeout);
}

void RedFinger_glDeleteSync(GLsync to_delete)
{
		GET_CONTEXT_client; 
	ctx->glDeleteSync(ctx, to_delete);
}

GLboolean RedFinger_glIsSync(GLsync sync)
{
		GET_CONTEXT_client; 
	return ctx->glIsSync(ctx, sync);
}

void RedFinger_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values)
{
		GET_CONTEXT_client; 
	ctx->glGetSynciv(ctx, sync, pname, bufSize, length, values);
}

uint64_t RedFinger_glFenceSyncAEMU(GLenum condition, GLbitfield flags)
{
	GET_CONTEXT_client; 
	 return ctx->glFenceSyncAEMU(ctx, condition, flags);
}

GLenum RedFinger_glClientWaitSyncAEMU(uint64_t wait_on, GLbitfield flags, GLuint64 timeout)
{
	GET_CONTEXT_client; 
	 return ctx->glClientWaitSyncAEMU(ctx, wait_on, flags, timeout);
}

void RedFinger_glWaitSyncAEMU(uint64_t wait_on, GLbitfield flags, GLuint64 timeout)
{
	GET_CONTEXT_client; 
	 ctx->glWaitSyncAEMU(ctx, wait_on, flags, timeout);
}

void RedFinger_glDeleteSyncAEMU(uint64_t to_delete)
{
	GET_CONTEXT_client; 
	 ctx->glDeleteSyncAEMU(ctx, to_delete);
}

GLboolean RedFinger_glIsSyncAEMU(uint64_t sync)
{
	GET_CONTEXT_client; 
	 return ctx->glIsSyncAEMU(ctx, sync);
}

void RedFinger_glGetSyncivAEMU(uint64_t sync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint* values)
{
	GET_CONTEXT_client; 
	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetSyncivAEMU(ctx, sync, pname, bufSize, length, values);
}

void RedFinger_glDrawBuffers(GLsizei n, const GLenum* bufs)
{
	GET_CONTEXT_client; 
	 ctx->glDrawBuffers(ctx, n, bufs);
}

void RedFinger_glReadBuffer(GLenum src)
{
	GET_CONTEXT_client; 
	 ctx->glReadBuffer(ctx, src);
}

void RedFinger_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
	GET_CONTEXT_client; 
	 ctx->glBlitFramebuffer(ctx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

void RedFinger_glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments)
{
	GET_CONTEXT_client; 
	 ctx->glInvalidateFramebuffer(ctx, target, numAttachments, attachments);
}

void RedFinger_glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glInvalidateSubFramebuffer(ctx, target, numAttachments, attachments, x, y, width, height);
}

void RedFinger_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
	GET_CONTEXT_client; 
	 ctx->glFramebufferTextureLayer(ctx, target, attachment, texture, level, layer);
}

void RedFinger_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glRenderbufferStorageMultisample(ctx, target, samples, internalformat, width, height);
}

void RedFinger_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glTexStorage2D(ctx, target, levels, internalformat, width, height);
}

void RedFinger_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetInternalformativ(ctx, target, internalformat, pname, bufSize, params);
}

void RedFinger_glBeginTransformFeedback(GLenum primitiveMode)
{
	GET_CONTEXT_client; 
	 ctx->glBeginTransformFeedback(ctx, primitiveMode);
}

void RedFinger_glEndTransformFeedback()
{
	GET_CONTEXT_client; 
	 ctx->glEndTransformFeedback(ctx);
}

void RedFinger_glGenTransformFeedbacks(GLsizei n, GLuint* ids)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenTransformFeedbacks(ctx, n, ids);
}

void RedFinger_glDeleteTransformFeedbacks(GLsizei n, const GLuint* ids)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteTransformFeedbacks(ctx, n, ids);
}

void RedFinger_glBindTransformFeedback(GLenum target, GLuint id)
{
	GET_CONTEXT_client; 
	 ctx->glBindTransformFeedback(ctx, target, id);
}

void RedFinger_glPauseTransformFeedback()
{
	GET_CONTEXT_client; 
	 ctx->glPauseTransformFeedback(ctx);
}

void RedFinger_glResumeTransformFeedback()
{
	GET_CONTEXT_client; 
	 ctx->glResumeTransformFeedback(ctx);
}

GLboolean RedFinger_glIsTransformFeedback(GLuint id)
{
	GET_CONTEXT_client; 
	 return ctx->glIsTransformFeedback(ctx, id);
}

void RedFinger_glTransformFeedbackVaryings(GLuint program, GLsizei count, const char** var3, GLenum bufferMode)
{
		GET_CONTEXT_client; 
	ctx->glTransformFeedbackVaryings(ctx, program, count, var3, bufferMode);
}

void RedFinger_glTransformFeedbackVaryingsAEMU(GLuint program, GLsizei count, const char* packedVaryings, GLuint packedVaryingsLen, GLenum bufferMode)
{
	GET_CONTEXT_client; 
	 ctx->glTransformFeedbackVaryingsAEMU(ctx, program, count, packedVaryings, packedVaryingsLen, bufferMode);
}

void RedFinger_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, char* name)
{
	GET_CONTEXT_client; 
	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetTransformFeedbackVarying(ctx, program, index, bufSize, length, size, type, name);
}

void RedFinger_glGenSamplers(GLsizei n, GLuint* samplers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenSamplers(ctx, n, samplers);
}

void RedFinger_glDeleteSamplers(GLsizei n, const GLuint* samplers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteSamplers(ctx, n, samplers);
}

void RedFinger_glBindSampler(GLuint unit, GLuint sampler)
{
	GET_CONTEXT_client; 
	 ctx->glBindSampler(ctx, unit, sampler);
}

void RedFinger_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
	GET_CONTEXT_client; 
	 ctx->glSamplerParameterf(ctx, sampler, pname, param);
}

void RedFinger_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
	GET_CONTEXT_client; 
	 ctx->glSamplerParameteri(ctx, sampler, pname, param);
}

void RedFinger_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glSamplerParameterfv(ctx, sampler, pname, params);
}

void RedFinger_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glSamplerParameteriv(ctx, sampler, pname, params);
}

void RedFinger_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetSamplerParameterfv(ctx, sampler, pname, params);
}

void RedFinger_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetSamplerParameteriv(ctx, sampler, pname, params);
}

GLboolean RedFinger_glIsSampler(GLuint sampler)
{
	GET_CONTEXT_client; 
	 return ctx->glIsSampler(ctx, sampler);
}

void RedFinger_glGenQueries(GLsizei n, GLuint* queries)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenQueries(ctx, n, queries);
}

void RedFinger_glDeleteQueries(GLsizei n, const GLuint* queries)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteQueries(ctx, n, queries);
}

void RedFinger_glBeginQuery(GLenum target, GLuint query)
{
	GET_CONTEXT_client; 
	 ctx->glBeginQuery(ctx, target, query);
}

void RedFinger_glEndQuery(GLenum target)
{
	GET_CONTEXT_client; 
	 ctx->glEndQuery(ctx, target);
}

void RedFinger_glGetQueryiv(GLenum target, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetQueryiv(ctx, target, pname, params);
}

void RedFinger_glGetQueryObjectuiv(GLuint query, GLenum pname, GLuint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetQueryObjectuiv(ctx, query, pname, params);
}

GLboolean RedFinger_glIsQuery(GLuint query)
{
	GET_CONTEXT_client; 
	 return ctx->glIsQuery(ctx, query);
}

void RedFinger_glProgramParameteri(GLuint program, GLenum pname, GLint value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramParameteri(ctx, program, pname, value);
}

void RedFinger_glProgramBinary(GLuint program, GLenum binaryFormat, const void* binary, GLsizei length)
{
	GET_CONTEXT_client; 
	 ctx->glProgramBinary(ctx, program, binaryFormat, binary, length);
}

void RedFinger_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void* binary)
{
	GET_CONTEXT_client; 
	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetProgramBinary(ctx, program, bufSize, length, binaryFormat, binary);
}

GLint RedFinger_glGetFragDataLocation(GLuint program, const char* name)
{
	GET_CONTEXT_client; 
	 return ctx->glGetFragDataLocation(ctx, program, name);
}

void RedFinger_glGetInteger64v(GLenum pname, GLint64* data)
{
	GET_CONTEXT_client; 
	 ctx->glGetInteger64v(ctx, pname, data);
}

void RedFinger_glGetIntegeri_v(GLenum target, GLuint index, GLint* data)
{
	GET_CONTEXT_client; 
	 ctx->glGetIntegeri_v(ctx, target, index, data);
}

void RedFinger_glGetInteger64i_v(GLenum target, GLuint index, GLint64* data)
{
	GET_CONTEXT_client; 
	 ctx->glGetInteger64i_v(ctx, target, index, data);
}

void RedFinger_glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* data)
{
	GET_CONTEXT_client; 
	 ctx->glTexImage3D(ctx, target, level, internalFormat, width, height, depth, border, format, type, data);
}

void RedFinger_glTexImage3DOffsetAEMU(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glTexImage3DOffsetAEMU(ctx, target, level, internalFormat, width, height, depth, border, format, type, offset);
}

void RedFinger_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
	GET_CONTEXT_client; 
	 ctx->glTexStorage3D(ctx, target, levels, internalformat, width, height, depth);
}

void RedFinger_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* data)
{
	GET_CONTEXT_client; 
	 ctx->glTexSubImage3D(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
}

void RedFinger_glTexSubImage3DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glTexSubImage3DOffsetAEMU(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, offset);
}

void RedFinger_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT_client; 
	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glCompressedTexImage3D(ctx, target, level, internalformat, width, height, depth, border, imageSize, data);
}

void RedFinger_glCompressedTexImage3DOffsetAEMU(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glCompressedTexImage3DOffsetAEMU(ctx, target, level, internalformat, width, height, depth, border, imageSize, offset);
}

void RedFinger_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data)
{
	GET_CONTEXT_client; 
	 if(imageSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glCompressedTexSubImage3D(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

void RedFinger_glCompressedTexSubImage3DOffsetAEMU(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLuint data)
{
	GET_CONTEXT_client; 
	 ctx->glCompressedTexSubImage3DOffsetAEMU(ctx, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

void RedFinger_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glCopyTexSubImage3D(ctx, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

const GLubyte* RedFinger_glGetStringi(GLenum name, GLuint index)
{
	GET_CONTEXT_client; 
	 return ctx->glGetStringi(ctx, name, index);
}

void RedFinger_glGetBooleani_v(GLenum target, GLuint index, GLboolean* data)
{
	GET_CONTEXT_client; 
	 ctx->glGetBooleani_v(ctx, target, index, data);
}

void RedFinger_glMemoryBarrier(GLbitfield barriers)
{
	GET_CONTEXT_client; 
	 ctx->glMemoryBarrier(ctx, barriers);
}

void RedFinger_glMemoryBarrierByRegion(GLbitfield barriers)
{
	GET_CONTEXT_client; 
	 ctx->glMemoryBarrierByRegion(ctx, barriers);
}

void RedFinger_glGenProgramPipelines(GLsizei n, GLuint* pipelines)
{
	GET_CONTEXT_client; 
	 ctx->glGenProgramPipelines(ctx, n, pipelines);
}

void RedFinger_glDeleteProgramPipelines(GLsizei n, const GLuint* pipelines)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteProgramPipelines(ctx, n, pipelines);
}

void RedFinger_glBindProgramPipeline(GLuint pipeline)
{
	GET_CONTEXT_client; 
	 ctx->glBindProgramPipeline(ctx, pipeline);
}

void RedFinger_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetProgramPipelineiv(ctx, pipeline, pname, params);
}

void RedFinger_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog)
{
	GET_CONTEXT_client; 
	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetProgramPipelineInfoLog(ctx, pipeline, bufSize, length, infoLog);
}

void RedFinger_glValidateProgramPipeline(GLuint pipeline)
{
	GET_CONTEXT_client; 
	 ctx->glValidateProgramPipeline(ctx, pipeline);
}

GLboolean RedFinger_glIsProgramPipeline(GLuint pipeline)
{
	GET_CONTEXT_client; 
	 return ctx->glIsProgramPipeline(ctx, pipeline);
}

void RedFinger_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
{
	GET_CONTEXT_client; 
	 ctx->glUseProgramStages(ctx, pipeline, stages, program);
}

void RedFinger_glActiveShaderProgram(GLuint pipeline, GLuint program)
{
	GET_CONTEXT_client; 
	 ctx->glActiveShaderProgram(ctx, pipeline, program);
}

GLuint RedFinger_glCreateShaderProgramv(GLenum type, GLsizei count, const char** var3)
{
	GET_CONTEXT_client; 
	 return ctx->glCreateShaderProgramv(ctx, type, count, var3);
}

GLuint RedFinger_glCreateShaderProgramvAEMU(GLenum type, GLsizei count, const char* packedStrings, GLuint packedLen)
{
	GET_CONTEXT_client; 
	 return ctx->glCreateShaderProgramvAEMU(ctx, type, count, packedStrings, packedLen);
}

void RedFinger_glProgramUniform1f(GLuint program, GLint location, GLfloat v0)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform1f(ctx, program, location, v0);
}

void RedFinger_glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform2f(ctx, program, location, v0, v1);
}

void RedFinger_glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform3f(ctx, program, location, v0, v1, v2);
}

void RedFinger_glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform4f(ctx, program, location, v0, v1, v2, v3);
}

void RedFinger_glProgramUniform1i(GLuint program, GLint location, GLint v0)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform1i(ctx, program, location, v0);
}

void RedFinger_glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform2i(ctx, program, location, v0, v1);
}

void RedFinger_glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform3i(ctx, program, location, v0, v1, v2);
}

void RedFinger_glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform4i(ctx, program, location, v0, v1, v2, v3);
}

void RedFinger_glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform1ui(ctx, program, location, v0);
}

void RedFinger_glProgramUniform2ui(GLuint program, GLint location, GLint v0, GLuint v1)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform2ui(ctx, program, location, v0, v1);
}

void RedFinger_glProgramUniform3ui(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform3ui(ctx, program, location, v0, v1, v2);
}

void RedFinger_glProgramUniform4ui(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform4ui(ctx, program, location, v0, v1, v2, v3);
}

void RedFinger_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform1fv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform2fv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform3fv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform4fv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform1iv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform2iv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform3iv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform4iv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform1uiv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform2uiv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform3uiv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniform4uiv(ctx, program, location, count, value);
}

void RedFinger_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniformMatrix2fv(ctx, program, location, count, transpose, value);
}

void RedFinger_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniformMatrix3fv(ctx, program, location, count, transpose, value);
}

void RedFinger_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniformMatrix4fv(ctx, program, location, count, transpose, value);
}

void RedFinger_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniformMatrix2x3fv(ctx, program, location, count, transpose, value);
}

void RedFinger_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniformMatrix3x2fv(ctx, program, location, count, transpose, value);
}

void RedFinger_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniformMatrix2x4fv(ctx, program, location, count, transpose, value);
}

void RedFinger_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniformMatrix4x2fv(ctx, program, location, count, transpose, value);
}

void RedFinger_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniformMatrix3x4fv(ctx, program, location, count, transpose, value);
}

void RedFinger_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value)
{
	GET_CONTEXT_client; 
	 ctx->glProgramUniformMatrix4x3fv(ctx, program, location, count, transpose, value);
}

void RedFinger_glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetProgramInterfaceiv(ctx, program, programInterface, pname, params);
}

void RedFinger_glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei* length, GLint* params)
{
	GET_CONTEXT_client; 
	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetProgramResourceiv(ctx, program, programInterface, index, propCount, props, bufSize, length, params);
}

GLuint RedFinger_glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char* name)
{
	GET_CONTEXT_client; 
	 return ctx->glGetProgramResourceIndex(ctx, program, programInterface, name);
}

GLint RedFinger_glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char* name)
{
	GET_CONTEXT_client; 
	 return ctx->glGetProgramResourceLocation(ctx, program, programInterface, name);
}

void RedFinger_glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, char* name)
{
	GET_CONTEXT_client; 
	 if(bufSize<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGetProgramResourceName(ctx, program, programInterface, index, bufSize, length, name);
}

void RedFinger_glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
{
	GET_CONTEXT_client; 
	 ctx->glBindImageTexture(ctx, unit, texture, level, layered, layer, access, format);
}

void RedFinger_glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
{
	GET_CONTEXT_client; 
	 ctx->glDispatchCompute(ctx, num_groups_x, num_groups_y, num_groups_z);
}

void RedFinger_glDispatchComputeIndirect(GLintptr indirect)
{
	GET_CONTEXT_client; 
	 ctx->glDispatchComputeIndirect(ctx, indirect);
}

void RedFinger_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride)
{
	GET_CONTEXT_client; 
	 ctx->glBindVertexBuffer(ctx, bindingindex, buffer, offset, stride);
}

void RedFinger_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribBinding(ctx, attribindex, bindingindex);
}

void RedFinger_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribFormat(ctx, attribindex, size, type, normalized, relativeoffset);
}

void RedFinger_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
	GET_CONTEXT_client; 
	 ctx->glVertexAttribIFormat(ctx, attribindex, size, type, relativeoffset);
}

void RedFinger_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
{
	GET_CONTEXT_client; 
	 ctx->glVertexBindingDivisor(ctx, bindingindex, divisor);
}

void RedFinger_glDrawArraysIndirect(GLenum mode, const void* indirect)
{
		GET_CONTEXT_client; 
	ctx->glDrawArraysIndirect(ctx, mode, indirect);
}

void RedFinger_glDrawArraysIndirectDataAEMU(GLenum mode, const void* indirect, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glDrawArraysIndirectDataAEMU(ctx, mode, indirect, datalen);
}

void RedFinger_glDrawArraysIndirectOffsetAEMU(GLenum mode, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glDrawArraysIndirectOffsetAEMU(ctx, mode, offset);
}

void RedFinger_glDrawElementsIndirect(GLenum mode, GLenum type, const void* indirect)
{
		GET_CONTEXT_client; 
	ctx->glDrawElementsIndirect(ctx, mode, type, indirect);
}

void RedFinger_glDrawElementsIndirectDataAEMU(GLenum mode, GLenum type, const void* indirect, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glDrawElementsIndirectDataAEMU(ctx, mode, type, indirect, datalen);
}

void RedFinger_glDrawElementsIndirectOffsetAEMU(GLenum mode, GLenum type, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glDrawElementsIndirectOffsetAEMU(ctx, mode, type, offset);
}

void RedFinger_glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
	GET_CONTEXT_client; 
	 ctx->glTexStorage2DMultisample(ctx, target, samples, internalformat, width, height, fixedsamplelocations);
}

void RedFinger_glSampleMaski(GLuint maskNumber, GLbitfield mask)
{
	GET_CONTEXT_client; 
	 ctx->glSampleMaski(ctx, maskNumber, mask);
}

void RedFinger_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat* val)
{
	GET_CONTEXT_client; 
	 ctx->glGetMultisamplefv(ctx, pname, index, val);
}

void RedFinger_glFramebufferParameteri(GLenum target, GLenum pname, GLint param)
{
	GET_CONTEXT_client; 
	 ctx->glFramebufferParameteri(ctx, target, pname, param);
}

void RedFinger_glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetFramebufferParameteriv(ctx, target, pname, params);
}

void RedFinger_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexLevelParameterfv(ctx, target, level, pname, params);
}

void RedFinger_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexLevelParameteriv(ctx, target, level, pname, params);
}

void RedFinger_glAlphaFunc(GLenum func, GLclampf ref)
{
	GET_CONTEXT_client; 
	 ctx->glAlphaFunc(ctx, func, ref);
}

void RedFinger_glClipPlanef(GLenum plane, const GLfloat* equation)
{
	GET_CONTEXT_client; 
	 ctx->glClipPlanef(ctx, plane, equation);
}

void RedFinger_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
	GET_CONTEXT_client; 
	 ctx->glColor4f(ctx, red, green, blue, alpha);
}

void RedFinger_glFogf(GLenum pname, GLfloat param)
{
	GET_CONTEXT_client; 
	 ctx->glFogf(ctx, pname, param);
}

void RedFinger_glFogfv(GLenum pname, const GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glFogfv(ctx, pname, params);
}

void RedFinger_glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
	GET_CONTEXT_client; 
	 ctx->glFrustumf(ctx, left, right, bottom, top, zNear, zFar);
}

void RedFinger_glGetClipPlanef(GLenum pname, GLfloat* eqn)
{
	GET_CONTEXT_client; 
	 ctx->glGetClipPlanef(ctx, pname, eqn);
}

void RedFinger_glGetLightfv(GLenum light, GLenum pname, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetLightfv(ctx, light, pname, params);
}

void RedFinger_glGetMaterialfv(GLenum face, GLenum pname, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetMaterialfv(ctx, face, pname, params);
}

void RedFinger_glGetTexEnvfv(GLenum env, GLenum pname, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexEnvfv(ctx, env, pname, params);
}

void RedFinger_glLightModelf(GLenum pname, GLfloat param)
{
	GET_CONTEXT_client; 
	 ctx->glLightModelf(ctx, pname, param);
}

void RedFinger_glLightModelfv(GLenum pname, const GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glLightModelfv(ctx, pname, params);
}

void RedFinger_glLightf(GLenum light, GLenum pname, GLfloat param)
{
	GET_CONTEXT_client; 
	 ctx->glLightf(ctx, light, pname, param);
}

void RedFinger_glLightfv(GLenum light, GLenum pname, const GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glLightfv(ctx, light, pname, params);
}

void RedFinger_glLoadMatrixf(const GLfloat* m)
{
	GET_CONTEXT_client; 
	 ctx->glLoadMatrixf(ctx, m);
}

void RedFinger_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
	GET_CONTEXT_client; 
	 ctx->glMaterialf(ctx, face, pname, param);
}

void RedFinger_glMaterialfv(GLenum face, GLenum pname, const GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glMaterialfv(ctx, face, pname, params);
}

void RedFinger_glMultMatrixf(const GLfloat* m)
{
	GET_CONTEXT_client; 
	 ctx->glMultMatrixf(ctx, m);
}

void RedFinger_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
	GET_CONTEXT_client; 
	 ctx->glMultiTexCoord4f(ctx, target, s, t, r, q);
}

void RedFinger_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
	GET_CONTEXT_client; 
	 ctx->glNormal3f(ctx, nx, ny, nz);
}

void RedFinger_glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
	GET_CONTEXT_client; 
	 ctx->glOrthof(ctx, left, right, bottom, top, zNear, zFar);
}

void RedFinger_glPointParameterf(GLenum pname, GLfloat param)
{
	GET_CONTEXT_client; 
	 ctx->glPointParameterf(ctx, pname, param);
}

void RedFinger_glPointParameterfv(GLenum pname, const GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glPointParameterfv(ctx, pname, params);
}

void RedFinger_glPointSize(GLfloat size)
{
	GET_CONTEXT_client; 
	 ctx->glPointSize(ctx, size);
}

void RedFinger_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
	GET_CONTEXT_client; 
	 ctx->glRotatef(ctx, angle, x, y, z);
}

void RedFinger_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
	GET_CONTEXT_client; 
	 ctx->glScalef(ctx, x, y, z);
}

void RedFinger_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
	GET_CONTEXT_client; 
	 ctx->glTexEnvf(ctx, target, pname, param);
}

void RedFinger_glTexEnvfv(GLenum target, GLenum pname, const GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexEnvfv(ctx, target, pname, params);
}

void RedFinger_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
	GET_CONTEXT_client; 
	 ctx->glTranslatef(ctx, x, y, z);
}

void RedFinger_glAlphaFuncx(GLenum func, GLclampx ref)
{
	GET_CONTEXT_client; 
	 ctx->glAlphaFuncx(ctx, func, ref);
}

void RedFinger_glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
{
	GET_CONTEXT_client; 
	 ctx->glClearColorx(ctx, red, green, blue, alpha);
}

void RedFinger_glClearDepthx(GLclampx depth)
{
	GET_CONTEXT_client; 
	 ctx->glClearDepthx(ctx, depth);
}

void RedFinger_glClientActiveTexture(GLenum texture)
{
		GET_CONTEXT_client; 
	ctx->glClientActiveTexture(ctx, texture);
}

void RedFinger_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
	GET_CONTEXT_client; 
	 ctx->glColor4ub(ctx, red, green, blue, alpha);
}

void RedFinger_glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
	GET_CONTEXT_client; 
	 ctx->glColor4x(ctx, red, green, blue, alpha);
}

void RedFinger_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer)
{
		GET_CONTEXT_client; 
	ctx->glColorPointer(ctx, size, type, stride, pointer);
}

void RedFinger_glDepthRangex(GLclampx zNear, GLclampx zFar)
{
	GET_CONTEXT_client; 
	 ctx->glDepthRangex(ctx, zNear, zFar);
}

void RedFinger_glDisableClientState(GLenum array)
{
		GET_CONTEXT_client; 
	ctx->glDisableClientState(ctx, array);
}

void RedFinger_glEnableClientState(GLenum array)
{
		GET_CONTEXT_client; 
	ctx->glEnableClientState(ctx, array);
}

void RedFinger_glFogx(GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glFogx(ctx, pname, param);
}

void RedFinger_glFogxv(GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glFogxv(ctx, pname, params);
}

void RedFinger_glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
	GET_CONTEXT_client; 
	 ctx->glFrustumx(ctx, left, right, bottom, top, zNear, zFar);
}

void RedFinger_glClipPlanex(GLenum pname, const GLfixed* eqn)
{
	GET_CONTEXT_client; 
	 ctx->glClipPlanex(ctx, pname, eqn);
}

void RedFinger_glGetFixedv(GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetFixedv(ctx, pname, params);
}

void RedFinger_glGetLightxv(GLenum light, GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetLightxv(ctx, light, pname, params);
}

void RedFinger_glGetMaterialxv(GLenum face, GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetMaterialxv(ctx, face, pname, params);
}

void RedFinger_glGetPointerv(GLenum pname, GLvoid** params)
{
	GET_CONTEXT_client; 
	 ctx->glGetPointerv(ctx, pname, params);
}

void RedFinger_glGetTexEnviv(GLenum env, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexEnviv(ctx, env, pname, params);
}

void RedFinger_glGetTexEnvxv(GLenum env, GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexEnvxv(ctx, env, pname, params);
}

void RedFinger_glGetTexParameterxv(GLenum target, GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexParameterxv(ctx, target, pname, params);
}

void RedFinger_glLightModelx(GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glLightModelx(ctx, pname, param);
}

void RedFinger_glLightModelxv(GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glLightModelxv(ctx, pname, params);
}

void RedFinger_glLightx(GLenum light, GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glLightx(ctx, light, pname, param);
}

void RedFinger_glLightxv(GLenum light, GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glLightxv(ctx, light, pname, params);
}

void RedFinger_glLineWidthx(GLfixed width)
{
	GET_CONTEXT_client; 
	 ctx->glLineWidthx(ctx, width);
}

void RedFinger_glLoadIdentity()
{
	GET_CONTEXT_client; 
	 ctx->glLoadIdentity(ctx);
}

void RedFinger_glLoadMatrixx(const GLfixed* m)
{
	GET_CONTEXT_client; 
	 ctx->glLoadMatrixx(ctx, m);
}

void RedFinger_glLogicOp(GLenum opcode)
{
	GET_CONTEXT_client; 
	 ctx->glLogicOp(ctx, opcode);
}

void RedFinger_glMaterialx(GLenum face, GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glMaterialx(ctx, face, pname, param);
}

void RedFinger_glMaterialxv(GLenum face, GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glMaterialxv(ctx, face, pname, params);
}

void RedFinger_glMatrixMode(GLenum mode)
{
	GET_CONTEXT_client; 
	 ctx->glMatrixMode(ctx, mode);
}

void RedFinger_glMultMatrixx(const GLfixed* m)
{
	GET_CONTEXT_client; 
	 ctx->glMultMatrixx(ctx, m);
}

void RedFinger_glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
	GET_CONTEXT_client; 
	 ctx->glMultiTexCoord4x(ctx, target, s, t, r, q);
}

void RedFinger_glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz)
{
	GET_CONTEXT_client; 
	 ctx->glNormal3x(ctx, nx, ny, nz);
}

void RedFinger_glNormalPointer(GLenum type, GLsizei stride, const GLvoid* pointer)
{
		GET_CONTEXT_client; 
	ctx->glNormalPointer(ctx, type, stride, pointer);
}

void RedFinger_glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
	GET_CONTEXT_client; 
	 ctx->glOrthox(ctx, left, right, bottom, top, zNear, zFar);
}

void RedFinger_glPointParameterx(GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glPointParameterx(ctx, pname, param);
}

void RedFinger_glPointParameterxv(GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glPointParameterxv(ctx, pname, params);
}

void RedFinger_glPointSizex(GLfixed size)
{
	GET_CONTEXT_client; 
	 ctx->glPointSizex(ctx, size);
}

void RedFinger_glPolygonOffsetx(GLfixed factor, GLfixed units)
{
	GET_CONTEXT_client; 
	 ctx->glPolygonOffsetx(ctx, factor, units);
}

void RedFinger_glPopMatrix()
{
	GET_CONTEXT_client; 
	 ctx->glPopMatrix(ctx);
}

void RedFinger_glPushMatrix()
{
	GET_CONTEXT_client; 
	 ctx->glPushMatrix(ctx);
}

void RedFinger_glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
	GET_CONTEXT_client; 
	 ctx->glRotatex(ctx, angle, x, y, z);
}

void RedFinger_glSampleCoveragex(GLclampx value, GLboolean invert)
{
	GET_CONTEXT_client; 
	 ctx->glSampleCoveragex(ctx, value, invert);
}

void RedFinger_glScalex(GLfixed x, GLfixed y, GLfixed z)
{
	GET_CONTEXT_client; 
	 ctx->glScalex(ctx, x, y, z);
}

void RedFinger_glShadeModel(GLenum mode)
{
	GET_CONTEXT_client; 
	 ctx->glShadeModel(ctx, mode);
}

void RedFinger_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer)
{
		GET_CONTEXT_client; 
	ctx->glTexCoordPointer(ctx, size, type, stride, pointer);
}

void RedFinger_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
	GET_CONTEXT_client; 
	 ctx->glTexEnvi(ctx, target, pname, param);
}

void RedFinger_glTexEnvx(GLenum target, GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glTexEnvx(ctx, target, pname, param);
}

void RedFinger_glTexEnviv(GLenum target, GLenum pname, const GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexEnviv(ctx, target, pname, params);
}

void RedFinger_glTexEnvxv(GLenum target, GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexEnvxv(ctx, target, pname, params);
}

void RedFinger_glTexParameterx(GLenum target, GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glTexParameterx(ctx, target, pname, param);
}

void RedFinger_glTexParameterxv(GLenum target, GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexParameterxv(ctx, target, pname, params);
}

void RedFinger_glTranslatex(GLfixed x, GLfixed y, GLfixed z)
{
	GET_CONTEXT_client; 
	 ctx->glTranslatex(ctx, x, y, z);
}

void RedFinger_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer)
{
		GET_CONTEXT_client; 
	ctx->glVertexPointer(ctx, size, type, stride, pointer);
}

void RedFinger_glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid* pointer)
{
		GET_CONTEXT_client; 
	ctx->glPointSizePointerOES(ctx, type, stride, pointer);
}

void RedFinger_glVertexPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glVertexPointerOffset(ctx, size, type, stride, offset);
}

void RedFinger_glColorPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glColorPointerOffset(ctx, size, type, stride, offset);
}

void RedFinger_glNormalPointerOffset(GLenum type, GLsizei stride, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glNormalPointerOffset(ctx, type, stride, offset);
}

void RedFinger_glPointSizePointerOffset(GLenum type, GLsizei stride, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glPointSizePointerOffset(ctx, type, stride, offset);
}

void RedFinger_glTexCoordPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glTexCoordPointerOffset(ctx, size, type, stride, offset);
}

void RedFinger_glWeightPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glWeightPointerOffset(ctx, size, type, stride, offset);
}

void RedFinger_glMatrixIndexPointerOffset(GLint size, GLenum type, GLsizei stride, GLuint offset)
{
	GET_CONTEXT_client; 
	 ctx->glMatrixIndexPointerOffset(ctx, size, type, stride, offset);
}

void RedFinger_glVertexPointerData(GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glVertexPointerData(ctx, size, type, stride, data, datalen);
}

void RedFinger_glColorPointerData(GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glColorPointerData(ctx, size, type, stride, data, datalen);
}

void RedFinger_glNormalPointerData(GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glNormalPointerData(ctx, type, stride, data, datalen);
}

void RedFinger_glTexCoordPointerData(GLint unit, GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glTexCoordPointerData(ctx, unit, size, type, stride, data, datalen);
}

void RedFinger_glPointSizePointerData(GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glPointSizePointerData(ctx, type, stride, data, datalen);
}

void RedFinger_glWeightPointerData(GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glWeightPointerData(ctx, size, type, stride, data, datalen);
}

void RedFinger_glMatrixIndexPointerData(GLint size, GLenum type, GLsizei stride, void* data, GLuint datalen)
{
	GET_CONTEXT_client; 
	 ctx->glMatrixIndexPointerData(ctx, size, type, stride, data, datalen);
}

void RedFinger_glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha)
{
	GET_CONTEXT_client; 
	 ctx->glBlendEquationSeparateOES(ctx, modeRGB, modeAlpha);
}

void RedFinger_glBlendFuncSeparateOES(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
	GET_CONTEXT_client; 
	 ctx->glBlendFuncSeparateOES(ctx, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

void RedFinger_glBlendEquationOES(GLenum mode)
{
	GET_CONTEXT_client; 
	 ctx->glBlendEquationOES(ctx, mode);
}

void RedFinger_glDrawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height)
{
	GET_CONTEXT_client; 
	 ctx->glDrawTexsOES(ctx, x, y, z, width, height);
}

void RedFinger_glDrawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height)
{
	GET_CONTEXT_client; 
	 ctx->glDrawTexiOES(ctx, x, y, z, width, height);
}

void RedFinger_glDrawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height)
{
	GET_CONTEXT_client; 
	 ctx->glDrawTexxOES(ctx, x, y, z, width, height);
}

void RedFinger_glDrawTexsvOES(const GLshort* coords)
{
	GET_CONTEXT_client; 
	 ctx->glDrawTexsvOES(ctx, coords);
}

void RedFinger_glDrawTexivOES(const GLint* coords)
{
	GET_CONTEXT_client; 
	 ctx->glDrawTexivOES(ctx, coords);
}

void RedFinger_glDrawTexxvOES(const GLfixed* coords)
{
	GET_CONTEXT_client; 
	 ctx->glDrawTexxvOES(ctx, coords);
}

void RedFinger_glDrawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height)
{
	GET_CONTEXT_client; 
	 ctx->glDrawTexfOES(ctx, x, y, z, width, height);
}

void RedFinger_glDrawTexfvOES(const GLfloat* coords)
{
	GET_CONTEXT_client; 
	 ctx->glDrawTexfvOES(ctx, coords);
}

void RedFinger_glAlphaFuncxOES(GLenum func, GLclampx ref)
{
	GET_CONTEXT_client; 
	 ctx->glAlphaFuncxOES(ctx, func, ref);
}

void RedFinger_glClearColorxOES(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
{
	GET_CONTEXT_client; 
	 ctx->glClearColorxOES(ctx, red, green, blue, alpha);
}

void RedFinger_glClearDepthxOES(GLclampx depth)
{
	GET_CONTEXT_client; 
	 ctx->glClearDepthxOES(ctx, depth);
}

void RedFinger_glClipPlanexOES(GLenum plane, const GLfixed* equation)
{
	GET_CONTEXT_client; 
	 ctx->glClipPlanexOES(ctx, plane, equation);
}

void RedFinger_glClipPlanexIMG(GLenum plane, const GLfixed* equation)
{
	GET_CONTEXT_client; 
	 ctx->glClipPlanexIMG(ctx, plane, equation);
}

void RedFinger_glColor4xOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
	GET_CONTEXT_client; 
	 ctx->glColor4xOES(ctx, red, green, blue, alpha);
}

void RedFinger_glDepthRangexOES(GLclampx zNear, GLclampx zFar)
{
	GET_CONTEXT_client; 
	 ctx->glDepthRangexOES(ctx, zNear, zFar);
}

void RedFinger_glFogxOES(GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glFogxOES(ctx, pname, param);
}

void RedFinger_glFogxvOES(GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glFogxvOES(ctx, pname, params);
}

void RedFinger_glFrustumxOES(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
	GET_CONTEXT_client; 
	 ctx->glFrustumxOES(ctx, left, right, bottom, top, zNear, zFar);
}

void RedFinger_glGetClipPlanexOES(GLenum pname, GLfixed* eqn)
{
	GET_CONTEXT_client; 
	 ctx->glGetClipPlanexOES(ctx, pname, eqn);
}

void RedFinger_glGetClipPlanex(GLenum pname, GLfixed* eqn)
{
	GET_CONTEXT_client; 
	 ctx->glGetClipPlanex(ctx, pname, eqn);
}

void RedFinger_glGetFixedvOES(GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetFixedvOES(ctx, pname, params);
}

void RedFinger_glGetLightxvOES(GLenum light, GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetLightxvOES(ctx, light, pname, params);
}

void RedFinger_glGetMaterialxvOES(GLenum face, GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetMaterialxvOES(ctx, face, pname, params);
}

void RedFinger_glGetTexEnvxvOES(GLenum env, GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexEnvxvOES(ctx, env, pname, params);
}

void RedFinger_glGetTexParameterxvOES(GLenum target, GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexParameterxvOES(ctx, target, pname, params);
}

void RedFinger_glLightModelxOES(GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glLightModelxOES(ctx, pname, param);
}

void RedFinger_glLightModelxvOES(GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glLightModelxvOES(ctx, pname, params);
}

void RedFinger_glLightxOES(GLenum light, GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glLightxOES(ctx, light, pname, param);
}

void RedFinger_glLightxvOES(GLenum light, GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glLightxvOES(ctx, light, pname, params);
}

void RedFinger_glLineWidthxOES(GLfixed width)
{
	GET_CONTEXT_client; 
	 ctx->glLineWidthxOES(ctx, width);
}

void RedFinger_glLoadMatrixxOES(const GLfixed* m)
{
	GET_CONTEXT_client; 
	 ctx->glLoadMatrixxOES(ctx, m);
}

void RedFinger_glMaterialxOES(GLenum face, GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glMaterialxOES(ctx, face, pname, param);
}

void RedFinger_glMaterialxvOES(GLenum face, GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glMaterialxvOES(ctx, face, pname, params);
}

void RedFinger_glMultMatrixxOES(const GLfixed* m)
{
	GET_CONTEXT_client; 
	 ctx->glMultMatrixxOES(ctx, m);
}

void RedFinger_glMultiTexCoord4xOES(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
	GET_CONTEXT_client; 
	 ctx->glMultiTexCoord4xOES(ctx, target, s, t, r, q);
}

void RedFinger_glNormal3xOES(GLfixed nx, GLfixed ny, GLfixed nz)
{
	GET_CONTEXT_client; 
	 ctx->glNormal3xOES(ctx, nx, ny, nz);
}

void RedFinger_glOrthoxOES(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
	GET_CONTEXT_client; 
	 ctx->glOrthoxOES(ctx, left, right, bottom, top, zNear, zFar);
}

void RedFinger_glPointParameterxOES(GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glPointParameterxOES(ctx, pname, param);
}

void RedFinger_glPointParameterxvOES(GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glPointParameterxvOES(ctx, pname, params);
}

void RedFinger_glPointSizexOES(GLfixed size)
{
	GET_CONTEXT_client; 
	 ctx->glPointSizexOES(ctx, size);
}

void RedFinger_glPolygonOffsetxOES(GLfixed factor, GLfixed units)
{
	GET_CONTEXT_client; 
	 ctx->glPolygonOffsetxOES(ctx, factor, units);
}

void RedFinger_glRotatexOES(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
	GET_CONTEXT_client; 
	 ctx->glRotatexOES(ctx, angle, x, y, z);
}

void RedFinger_glSampleCoveragexOES(GLclampx value, GLboolean invert)
{
	GET_CONTEXT_client; 
	 ctx->glSampleCoveragexOES(ctx, value, invert);
}

void RedFinger_glScalexOES(GLfixed x, GLfixed y, GLfixed z)
{
	GET_CONTEXT_client; 
	 ctx->glScalexOES(ctx, x, y, z);
}

void RedFinger_glTexEnvxOES(GLenum target, GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glTexEnvxOES(ctx, target, pname, param);
}

void RedFinger_glTexEnvxvOES(GLenum target, GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexEnvxvOES(ctx, target, pname, params);
}

void RedFinger_glTexParameterxOES(GLenum target, GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glTexParameterxOES(ctx, target, pname, param);
}

void RedFinger_glTexParameterxvOES(GLenum target, GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexParameterxvOES(ctx, target, pname, params);
}

void RedFinger_glTranslatexOES(GLfixed x, GLfixed y, GLfixed z)
{
	GET_CONTEXT_client; 
	 ctx->glTranslatexOES(ctx, x, y, z);
}

GLboolean RedFinger_glIsRenderbufferOES(GLuint renderbuffer)
{
	GET_CONTEXT_client; 
	 return ctx->glIsRenderbufferOES(ctx, renderbuffer);
}

void RedFinger_glBindRenderbufferOES(GLenum target, GLuint renderbuffer)
{
	GET_CONTEXT_client; 
	 ctx->glBindRenderbufferOES(ctx, target, renderbuffer);
}

void RedFinger_glDeleteRenderbuffersOES(GLsizei n, const GLuint* renderbuffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteRenderbuffersOES(ctx, n, renderbuffers);
}

void RedFinger_glGenRenderbuffersOES(GLsizei n, GLuint* renderbuffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenRenderbuffersOES(ctx, n, renderbuffers);
}

void RedFinger_glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
	GET_CONTEXT_client; 
	 ctx->glRenderbufferStorageOES(ctx, target, internalformat, width, height);
}

void RedFinger_glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetRenderbufferParameterivOES(ctx, target, pname, params);
}

GLboolean RedFinger_glIsFramebufferOES(GLuint framebuffer)
{
	GET_CONTEXT_client; 
	 return ctx->glIsFramebufferOES(ctx, framebuffer);
}

void RedFinger_glBindFramebufferOES(GLenum target, GLuint framebuffer)
{
	GET_CONTEXT_client; 
	 ctx->glBindFramebufferOES(ctx, target, framebuffer);
}

void RedFinger_glDeleteFramebuffersOES(GLsizei n, const GLuint* framebuffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glDeleteFramebuffersOES(ctx, n, framebuffers);
}

void RedFinger_glGenFramebuffersOES(GLsizei n, GLuint* framebuffers)
{
	GET_CONTEXT_client; 
	 if(n<0){ ctx->setError(GL_INVALID_VALUE); return; }
	 ctx->glGenFramebuffersOES(ctx, n, framebuffers);
}

GLenum RedFinger_glCheckFramebufferStatusOES(GLenum target)
{
	GET_CONTEXT_client; 
	 return ctx->glCheckFramebufferStatusOES(ctx, target);
}

void RedFinger_glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	GET_CONTEXT_client; 
	 ctx->glFramebufferRenderbufferOES(ctx, target, attachment, renderbuffertarget, renderbuffer);
}

void RedFinger_glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	GET_CONTEXT_client; 
	 ctx->glFramebufferTexture2DOES(ctx, target, attachment, textarget, texture, level);
}

void RedFinger_glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetFramebufferAttachmentParameterivOES(ctx, target, attachment, pname, params);
}

void RedFinger_glGenerateMipmapOES(GLenum target)
{
	GET_CONTEXT_client; 
	 ctx->glGenerateMipmapOES(ctx, target);
}

void RedFinger_glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid** params)
{
	GET_CONTEXT_client; 
	 ctx->glGetBufferPointervOES(ctx, target, pname, params);
}

void RedFinger_glCurrentPaletteMatrixOES(GLuint matrixpaletteindex)
{
	GET_CONTEXT_client; 
	 ctx->glCurrentPaletteMatrixOES(ctx, matrixpaletteindex);
}

void RedFinger_glLoadPaletteFromModelViewMatrixOES()
{
	GET_CONTEXT_client; 
	 ctx->glLoadPaletteFromModelViewMatrixOES(ctx);
}

void RedFinger_glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer)
{
		GET_CONTEXT_client; 
	ctx->glMatrixIndexPointerOES(ctx, size, type, stride, pointer);
}

void RedFinger_glWeightPointerOES(GLint size, GLenum type, GLsizei stride, const GLvoid* pointer)
{
		GET_CONTEXT_client; 
	ctx->glWeightPointerOES(ctx, size, type, stride, pointer);
}

GLbitfield RedFinger_glQueryMatrixxOES(GLfixed* mantissa, GLint* exponent)
{
	GET_CONTEXT_client; 
	 return ctx->glQueryMatrixxOES(ctx, mantissa, exponent);
}

void RedFinger_glDepthRangefOES(GLclampf zNear, GLclampf zFar)
{
	GET_CONTEXT_client; 
	 ctx->glDepthRangefOES(ctx, zNear, zFar);
}

void RedFinger_glFrustumfOES(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
	GET_CONTEXT_client; 
	 ctx->glFrustumfOES(ctx, left, right, bottom, top, zNear, zFar);
}

void RedFinger_glOrthofOES(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
	GET_CONTEXT_client; 
	 ctx->glOrthofOES(ctx, left, right, bottom, top, zNear, zFar);
}

void RedFinger_glClipPlanefOES(GLenum plane, const GLfloat* equation)
{
	GET_CONTEXT_client; 
	 ctx->glClipPlanefOES(ctx, plane, equation);
}

void RedFinger_glClipPlanefIMG(GLenum plane, const GLfloat* equation)
{
	GET_CONTEXT_client; 
	 ctx->glClipPlanefIMG(ctx, plane, equation);
}

void RedFinger_glGetClipPlanefOES(GLenum pname, GLfloat* eqn)
{
	GET_CONTEXT_client; 
	 ctx->glGetClipPlanefOES(ctx, pname, eqn);
}

void RedFinger_glClearDepthfOES(GLclampf depth)
{
	GET_CONTEXT_client; 
	 ctx->glClearDepthfOES(ctx, depth);
}

void RedFinger_glTexGenfOES(GLenum coord, GLenum pname, GLfloat param)
{
	GET_CONTEXT_client; 
	 ctx->glTexGenfOES(ctx, coord, pname, param);
}

void RedFinger_glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexGenfvOES(ctx, coord, pname, params);
}

void RedFinger_glTexGeniOES(GLenum coord, GLenum pname, GLint param)
{
	GET_CONTEXT_client; 
	 ctx->glTexGeniOES(ctx, coord, pname, param);
}

void RedFinger_glTexGenivOES(GLenum coord, GLenum pname, const GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexGenivOES(ctx, coord, pname, params);
}

void RedFinger_glTexGenxOES(GLenum coord, GLenum pname, GLfixed param)
{
	GET_CONTEXT_client; 
	 ctx->glTexGenxOES(ctx, coord, pname, param);
}

void RedFinger_glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glTexGenxvOES(ctx, coord, pname, params);
}

void RedFinger_glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexGenfvOES(ctx, coord, pname, params);
}

void RedFinger_glGetTexGenivOES(GLenum coord, GLenum pname, GLint* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexGenivOES(ctx, coord, pname, params);
}

void RedFinger_glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed* params)
{
	GET_CONTEXT_client; 
	 ctx->glGetTexGenxvOES(ctx, coord, pname, params);
}

void RedFinger_glMultiDrawArraysSUN(GLenum mode, GLint* first, GLsizei* count, GLsizei primcount)
{
	GET_CONTEXT_client; 
	 ctx->glMultiDrawArraysSUN(ctx, mode, first, count, primcount);
}

void RedFinger_glMultiDrawElementsSUN(GLenum mode, const GLsizei* count, GLenum type, const GLvoid** indices, GLsizei primcount)
{
	GET_CONTEXT_client; 
	 ctx->glMultiDrawElementsSUN(ctx, mode, count, type, indices, primcount);
}

