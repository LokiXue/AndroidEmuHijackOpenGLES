// Generated Code - DO NOT EDIT !!
// generated by 'emugen'
#include <stdio.h>
#include <stdlib.h>
#include "renderControl_client_context.h"
#include "ErrorLog.h"

#ifndef GLsync
typedef struct __GLsync *GLsync;
#endif


#ifndef GL_TRUE
extern "C" {
	GLint RedFinger_rcGetRendererVersion();
	EGLint RedFinger_rcGetEGLVersion(EGLint* major, EGLint* minor);
	EGLint RedFinger_rcQueryEGLString(EGLenum name, void* buffer, EGLint bufferSize);
	EGLint RedFinger_rcGetGLString(EGLenum name, void* buffer, EGLint bufferSize);
	EGLint RedFinger_rcGetNumConfigs(uint32_t* numAttribs);
	EGLint RedFinger_rcGetConfigs(uint32_t bufSize, GLuint* buffer);
	EGLint RedFinger_rcChooseConfig(EGLint* attribs, uint32_t attribs_size, uint32_t* configs, uint32_t configs_size);
	EGLint RedFinger_rcGetFBParam(EGLint param);
	uint32_t RedFinger_rcCreateContext(uint32_t config, uint32_t share, uint32_t glVersion);
	void RedFinger_rcDestroyContext(uint32_t context);
	uint32_t RedFinger_rcCreateWindowSurface(uint32_t config, uint32_t width, uint32_t height);
	void RedFinger_rcDestroyWindowSurface(uint32_t windowSurface);
	uint32_t RedFinger_rcCreateColorBuffer(uint32_t width, uint32_t height, GLenum internalFormat);
	void RedFinger_rcOpenColorBuffer(uint32_t colorbuffer);
	void RedFinger_rcCloseColorBuffer(uint32_t colorbuffer);
	void RedFinger_rcSetWindowColorBuffer(uint32_t windowSurface, uint32_t colorBuffer);
	int RedFinger_rcFlushWindowColorBuffer(uint32_t windowSurface);
	EGLint RedFinger_rcMakeCurrent(uint32_t context, uint32_t drawSurf, uint32_t readSurf);
	void RedFinger_rcFBPost(uint32_t colorBuffer);
	void RedFinger_rcFBSetSwapInterval(EGLint interval);
	void RedFinger_rcBindTexture(uint32_t colorBuffer);
	void RedFinger_rcBindRenderbuffer(uint32_t colorBuffer);
	EGLint RedFinger_rcColorBufferCacheFlush(uint32_t colorbuffer, EGLint postCount, int forRead);
	void RedFinger_rcReadColorBuffer(uint32_t colorbuffer, GLint x, GLint y, GLint width, GLint height, GLenum format, GLenum type, void* pixels);
	int RedFinger_rcUpdateColorBuffer(uint32_t colorbuffer, GLint x, GLint y, GLint width, GLint height, GLenum format, GLenum type, void* pixels);
	int RedFinger_rcOpenColorBuffer2(uint32_t colorbuffer);
	uint32_t RedFinger_rcCreateClientImage(uint32_t context, EGLenum target, GLuint buffer);
	int RedFinger_rcDestroyClientImage(uint32_t image);
	void RedFinger_rcSelectChecksumHelper(uint32_t newProtocol, uint32_t reserved);
	void RedFinger_rcCreateSyncKHR(EGLenum type, EGLint* attribs, uint32_t num_attribs, int destroy_when_signaled, uint64_t* glsync_out, uint64_t* syncthread_out);
	EGLint RedFinger_rcClientWaitSyncKHR(uint64_t sync, EGLint flags, uint64_t timeout);
	void RedFinger_rcFlushWindowColorBufferAsync(uint32_t windowSurface);
	int RedFinger_rcDestroySyncKHR(uint64_t sync);
	void RedFinger_rcSetPuid(uint64_t puid);
	int RedFinger_rcUpdateColorBufferDMA(uint32_t colorbuffer, GLint x, GLint y, GLint width, GLint height, GLenum format, GLenum type, void* pixels, uint32_t pixels_size);
	uint32_t RedFinger_rcCreateColorBufferDMA(uint32_t width, uint32_t height, GLenum internalFormat, int frameworkFormat);
};

#endif


#undef GET_CONTEXT_client
#ifndef GET_CONTEXT_client
static renderControl_client_context_t::CONTEXT_ACCESSOR_TYPE *getCurrentContext_client = NULL;
void renderControl_client_context_t::setContextAccessor(CONTEXT_ACCESSOR_TYPE *f) { getCurrentContext_client = f; }
#define GET_CONTEXT_client renderControl_client_context_t * ctx = getCurrentContext_client() 
#endif

GLint RedFinger_rcGetRendererVersion()
{
	GET_CONTEXT_client; 
	 return ctx->rcGetRendererVersion(ctx);
}

EGLint RedFinger_rcGetEGLVersion(EGLint* major, EGLint* minor)
{
	GET_CONTEXT_client; 
	 return ctx->rcGetEGLVersion(ctx, major, minor);
}

EGLint RedFinger_rcQueryEGLString(EGLenum name, void* buffer, EGLint bufferSize)
{
	GET_CONTEXT_client; 
	 return ctx->rcQueryEGLString(ctx, name, buffer, bufferSize);
}

EGLint RedFinger_rcGetGLString(EGLenum name, void* buffer, EGLint bufferSize)
{
	GET_CONTEXT_client; 
	 return ctx->rcGetGLString(ctx, name, buffer, bufferSize);
}

EGLint RedFinger_rcGetNumConfigs(uint32_t* numAttribs)
{
	GET_CONTEXT_client; 
	 return ctx->rcGetNumConfigs(ctx, numAttribs);
}

EGLint RedFinger_rcGetConfigs(uint32_t bufSize, GLuint* buffer)
{
	GET_CONTEXT_client; 
	 return ctx->rcGetConfigs(ctx, bufSize, buffer);
}

EGLint RedFinger_rcChooseConfig(EGLint* attribs, uint32_t attribs_size, uint32_t* configs, uint32_t configs_size)
{
	GET_CONTEXT_client; 
	 return ctx->rcChooseConfig(ctx, attribs, attribs_size, configs, configs_size);
}

EGLint RedFinger_rcGetFBParam(EGLint param)
{
	GET_CONTEXT_client; 
	 return ctx->rcGetFBParam(ctx, param);
}

uint32_t RedFinger_rcCreateContext(uint32_t config, uint32_t share, uint32_t glVersion)
{
	GET_CONTEXT_client; 
	 return ctx->rcCreateContext(ctx, config, share, glVersion);
}

void RedFinger_rcDestroyContext(uint32_t context)
{
	GET_CONTEXT_client; 
	 ctx->rcDestroyContext(ctx, context);
}

uint32_t RedFinger_rcCreateWindowSurface(uint32_t config, uint32_t width, uint32_t height)
{
	GET_CONTEXT_client; 
	 return ctx->rcCreateWindowSurface(ctx, config, width, height);
}

void RedFinger_rcDestroyWindowSurface(uint32_t windowSurface)
{
	GET_CONTEXT_client; 
	 ctx->rcDestroyWindowSurface(ctx, windowSurface);
}

uint32_t RedFinger_rcCreateColorBuffer(uint32_t width, uint32_t height, GLenum internalFormat)
{
	GET_CONTEXT_client; 
	 return ctx->rcCreateColorBuffer(ctx, width, height, internalFormat);
}

void RedFinger_rcOpenColorBuffer(uint32_t colorbuffer)
{
	GET_CONTEXT_client; 
	 ctx->rcOpenColorBuffer(ctx, colorbuffer);
}

void RedFinger_rcCloseColorBuffer(uint32_t colorbuffer)
{
	GET_CONTEXT_client; 
	 ctx->rcCloseColorBuffer(ctx, colorbuffer);
}

void RedFinger_rcSetWindowColorBuffer(uint32_t windowSurface, uint32_t colorBuffer)
{
	GET_CONTEXT_client; 
	 ctx->rcSetWindowColorBuffer(ctx, windowSurface, colorBuffer);
}

int RedFinger_rcFlushWindowColorBuffer(uint32_t windowSurface)
{
	GET_CONTEXT_client; 
	 return ctx->rcFlushWindowColorBuffer(ctx, windowSurface);
}

EGLint RedFinger_rcMakeCurrent(uint32_t context, uint32_t drawSurf, uint32_t readSurf)
{
	GET_CONTEXT_client; 
	 return ctx->rcMakeCurrent(ctx, context, drawSurf, readSurf);
}

void RedFinger_rcFBPost(uint32_t colorBuffer)
{
	GET_CONTEXT_client; 
	 ctx->rcFBPost(ctx, colorBuffer);
}

void RedFinger_rcFBSetSwapInterval(EGLint interval)
{
	GET_CONTEXT_client; 
	 ctx->rcFBSetSwapInterval(ctx, interval);
}

void RedFinger_rcBindTexture(uint32_t colorBuffer)
{
	GET_CONTEXT_client; 
	 ctx->rcBindTexture(ctx, colorBuffer);
}

void RedFinger_rcBindRenderbuffer(uint32_t colorBuffer)
{
	GET_CONTEXT_client; 
	 ctx->rcBindRenderbuffer(ctx, colorBuffer);
}

EGLint RedFinger_rcColorBufferCacheFlush(uint32_t colorbuffer, EGLint postCount, int forRead)
{
	GET_CONTEXT_client; 
	 return ctx->rcColorBufferCacheFlush(ctx, colorbuffer, postCount, forRead);
}

void RedFinger_rcReadColorBuffer(uint32_t colorbuffer, GLint x, GLint y, GLint width, GLint height, GLenum format, GLenum type, void* pixels)
{
	GET_CONTEXT_client; 
	 ctx->rcReadColorBuffer(ctx, colorbuffer, x, y, width, height, format, type, pixels);
}

int RedFinger_rcUpdateColorBuffer(uint32_t colorbuffer, GLint x, GLint y, GLint width, GLint height, GLenum format, GLenum type, void* pixels)
{
	GET_CONTEXT_client; 
	 return ctx->rcUpdateColorBuffer(ctx, colorbuffer, x, y, width, height, format, type, pixels);
}

int RedFinger_rcOpenColorBuffer2(uint32_t colorbuffer)
{
	GET_CONTEXT_client; 
	 return ctx->rcOpenColorBuffer2(ctx, colorbuffer);
}

uint32_t RedFinger_rcCreateClientImage(uint32_t context, EGLenum target, GLuint buffer)
{
	GET_CONTEXT_client; 
	 return ctx->rcCreateClientImage(ctx, context, target, buffer);
}

int RedFinger_rcDestroyClientImage(uint32_t image)
{
	GET_CONTEXT_client; 
	 return ctx->rcDestroyClientImage(ctx, image);
}

void RedFinger_rcSelectChecksumHelper(uint32_t newProtocol, uint32_t reserved)
{
	GET_CONTEXT_client; 
	 ctx->rcSelectChecksumHelper(ctx, newProtocol, reserved);
}

void RedFinger_rcCreateSyncKHR(EGLenum type, EGLint* attribs, uint32_t num_attribs, int destroy_when_signaled, uint64_t* glsync_out, uint64_t* syncthread_out)
{
	GET_CONTEXT_client; 
	 ctx->rcCreateSyncKHR(ctx, type, attribs, num_attribs, destroy_when_signaled, glsync_out, syncthread_out);
}

EGLint RedFinger_rcClientWaitSyncKHR(uint64_t sync, EGLint flags, uint64_t timeout)
{
	GET_CONTEXT_client; 
	 return ctx->rcClientWaitSyncKHR(ctx, sync, flags, timeout);
}

void RedFinger_rcFlushWindowColorBufferAsync(uint32_t windowSurface)
{
	GET_CONTEXT_client; 
	 ctx->rcFlushWindowColorBufferAsync(ctx, windowSurface);
}

int RedFinger_rcDestroySyncKHR(uint64_t sync)
{
	GET_CONTEXT_client; 
	 return ctx->rcDestroySyncKHR(ctx, sync);
}

void RedFinger_rcSetPuid(uint64_t puid)
{
	GET_CONTEXT_client; 
	 ctx->rcSetPuid(ctx, puid);
}

int RedFinger_rcUpdateColorBufferDMA(uint32_t colorbuffer, GLint x, GLint y, GLint width, GLint height, GLenum format, GLenum type, void* pixels, uint32_t pixels_size)
{
	GET_CONTEXT_client; 
	 return ctx->rcUpdateColorBufferDMA(ctx, colorbuffer, x, y, width, height, format, type, pixels, pixels_size);
}

uint32_t RedFinger_rcCreateColorBufferDMA(uint32_t width, uint32_t height, GLenum internalFormat, int frameworkFormat)
{
	GET_CONTEXT_client; 
	 return ctx->rcCreateColorBufferDMA(ctx, width, height, internalFormat, frameworkFormat);
}

